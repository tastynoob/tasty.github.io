{"meta":{"title":"tastynoob's blog","subtitle":"","description":"","author":"tastynoob","url":"https://tastynoob.github.io","root":"/"},"pages":[{"title":"PY","date":"2023-04-28T16:56:59.772Z","updated":"2023-04-28T16:56:51.118Z","comments":true,"path":"PY.html","permalink":"https://tastynoob.github.io/PY.html","excerpt":"","text":"这里就没啥好介绍的了就来推荐一下我一直以来的自学网站吧😘 菜鸟教程"},{"title":"关于博客","date":"2023-04-29T03:32:39.903Z","updated":"2023-04-29T03:32:39.903Z","comments":true,"path":"about.html","permalink":"https://tastynoob.github.io/about.html","excerpt":"","text":"三峡大学某菜鸡一位 该博客主要记录平常的学习和一些杂七杂八的东西 没啥好介绍的 闲来无事搞得玩的 博客使用github+hexo方式搭建 主题采用nexmoe"},{"title":"文章归档","date":"2023-04-28T16:56:59.767Z","updated":"2023-04-28T16:56:51.177Z","comments":true,"path":"archive.html","permalink":"https://tastynoob.github.io/archive.html","excerpt":"","text":""},{"title":"文章归档","date":"2023-04-28T16:56:59.768Z","updated":"2023-04-28T16:56:51.177Z","comments":true,"path":"archives.html","permalink":"https://tastynoob.github.io/archives.html","excerpt":"","text":""},{"title":"","date":"2023-04-28T16:56:59.771Z","updated":"2023-04-28T16:56:51.215Z","comments":true,"path":"myself.html","permalink":"https://tastynoob.github.io/myself.html","excerpt":"","text":"三峡大学某菜鸡一位 该博客主要记录FPGA的学习和一些杂七杂八的东西 不定期更新"}],"posts":[{"title":"高性能处理器设计与快速迭代方法","slug":"工作/高性能处理器设计与迭代方法","date":"2023-04-28T16:00:00.000Z","updated":"2023-04-29T08:18:18.048Z","comments":true,"path":"2023/04/29/工作/高性能处理器设计与迭代方法/","link":"","permalink":"https://tastynoob.github.io/2023/04/29/%E5%B7%A5%E4%BD%9C/%E9%AB%98%E6%80%A7%E8%83%BD%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95/","excerpt":"主要讲一下现代高性能处理器设计与性能迭代方法简单综合一下几个月的实习学习结果","text":"主要讲一下现代高性能处理器设计与性能迭代方法简单综合一下几个月的实习学习结果 现代高性能处理器设计思路超标量乱序执行高性能的基石,提高ILP 现代处理器后端一般结构比较固定 使用重命名算法消除指令假依赖,使用保留站乱序发射指令 deocde-&gt;rename-&gt;dispatch-&gt;issue-&gt;execute-&gt;writeback-&gt;commit(retire) 处理器后端基本技术 寄存器重命名 推测快速唤醒及replay机制 现代处理器还会额外使用基于寄存器重命名的mov消除技术,进一步提高ILP 推测唤醒预测器一条指令从被唤醒到写回一般需要以下几个周期 wakeup-&gt;select-&gt;issue-&gt;readData-&gt;execute-&gt;writeback 如果我们需要指令背靠背执行 则需要在第一条指令写回时,就已经在执行第二条指令了 所以我们需要对第二条指令进行推测唤醒 对于单周期执行的指令来说 只需要在第一条指令select时,就对其他指令进行唤醒即可 但是对于某些多周期指令(访存指令)来说,这个唤醒的时机并不确定 当然,我们可以简单的认为访存指令一定会命中L1Cache,再进行唤醒 考虑到实际情况,L1Cache的命中率较高,因此可以采取此方法 当然,也可以提前预测访存指令能否命中L1Cache,再决定唤醒其它指令的时机 强大的分支预测现代超标量乱序处理器流水长度基本在10-15之间,分支惩罚严重 因此需要分支预测器减少惩罚 现代高性能处理器往往有着非常复杂的分支预测器 目前主流的是混合式预测器,即多个预测器共同作用 香山处理器前端使用到了多个预测器 按照速度可以分类为: 能一个周期内得到结果的快速预测器,但是准确率差 准确率更高,但是需要多个周期才能得到结果的复杂预测器 这里主要挑复杂预测器来讲一下 TAGE预测器及其变体TAGE预测器的核心思想是不同的程序段可能会有不同长度的分支历史相关性 使用一个准确性计数器来决定某一个分支使用较长的全局分支历史进行预测还是使用较短的分支历史 比如有的程序段比较看重全局分支历史,有的程序段则比较看重局部分支历史 本质上是不同的分支历史长度对某一条分支指令的预测准确率 TAGE可以通过训练来权衡一条分支指令使用哪种分支历史长度的预测结果 TAGE还有不同变体,但本质上原理相似 相关论文A case for (partially) tagged geometric history length branch prediction A 64-Kbytes ITTAGE indirect branch predictor∗ 解偶的取指前端解偶的取指前端通常将取值与分支预测分离 因为分支预测速度实际上比取指快,如果等到取指取出指令再预测,可能会导致很多bubble 解偶的分支预测器可以提前取指进行预测,预测更未来的指令流 以供应足够的指令 (论文名我忘了,关键词:decoupled frontend,stream fetch engine) 乱序访存访存指令是限制现代处理器IPC的最大瓶颈 根本原因是存储器速度与高性能处理器速度的不均衡 因此现代处理器提高性能的方法之一就是提高MLP(memory level parallel) 由于访存不能像寄存器重命名那样消除指令假依赖 因此对于乱序访存,我们需要保证访存指令的依赖正确 一般情况下我们需要做访存依赖预测 如果一条访存指令被预测为无依赖,则直接执行 如果被预测为有依赖,则需要等待所依赖的访存指令执行完成才能执行当前的访存指令 storeset访存依赖预测器相关论文Memory Dependence Prediction using Store Sets 快速性能迭代核心原理当我们想知道某一项技术在我们的处理器上是否能带来性能提升时该怎么做? 很简单 将这项技术添加到处理器rtl中 使用rtl仿真器运行benchmark得到性能结果 将其与原始性能数据进行对比,我们就能知道这项技术是否有用 但最大的问题是 rtl代码修改麻烦,debug缓慢,往往需要几个月的时间 同时rtl仿真器运行极其缓慢(运行完整的spec06可能需要几年时间) 假如该技术没有任何作用,则意味着我们浪费了大量时间做无用功 假如我们能找到一种方法,能够快速(一个星期)得到修改后的性能结果进行比对 我们就能节省大量的无用功 因此除了rtl仿真器之外,我们需要一种速度更快的模拟器 gem5模拟器当我们使用hdl写好处理器后 需要进行仿真或者综合后在fpga上运行得到结果 以便测量处理器水平,方便进一步改进 但是目前rtl仿真器仿真速度慢,fpga综合慢,价格高 因此往往会使用速度更快的性能或时序模拟器来进行模拟运行 下面是几种处理器模型 模拟&#x2F;仿真器种类 模拟精度 模拟速度 用途 举例 使用便捷性 isa功能模拟器 无 极快 处理器行为验证 nemu&#x2F;qemu 高(只用于行为验证) 通用性能模拟器 较高 快 处理器性能验证 gem5 中(需要进行性能对齐) 时序模拟器 高 慢 处理器性能验证 (一般是根据处理器模型进行搭建) (需要自行搭建) rtl仿真器 极高 极慢 处理器rtl验证 iverilog&#x2F;verlator 高(自动生成rtl仿真模型) 实际上,性能测试往往可以与处理器架构分离 即模拟器使用a种架构,而处理器则采用b中架构 因此不可避免的会存在一定的性能测量误差(一般在10%左右) 但是仍能够反映处理器当前的性能 这点我们则可以使用gem5通用性能模拟器 在使用之前我们需要将gem5与待测试的处理器rtl进行性能对齐,以便得到更高精度的性能对比结果 但即使是gem5,运行完整的spec06仍然需要花上不少时间(一周左右) 有没有更快的方法,能够让性能测算时间缩短到一天之内? checkpoint采样实际上一个程序往往有不同的特征点 比如,在某一段时间内,分支指令比较多,在另一段时间内,访存指令比较多 当然实际可能不会按这样划分 但是把一个程序分成不同的子程序段的核心思想在于: 处理器运行一个程序的完整性能反映了处理器对该程序的特征的处理速度 比如(只是举例,实际checkpoint采样会使用特殊算法): 我们将一段程序均匀的分为100份,然后从中均匀挑选20份程序段(checkpoint采样) 我们再运行这20份checkpoints,得到20份局部性能数据后,进行加权和,就能够得到与完整程序的性能结果相似的性能数据 并且精度可达90%以上,由于实际上并没有运行完整的程序,因此性能测算时间可进一步减少 warmup 预热当我们得到checkpoint后,准备运行时 还需要做的一份十分重要的工作是预热,预热是什么下面会讲,我们先来看看为什么需要预热 运行完整程序与运行checkpoint的最大区别在于: 运行完整程序时,处理器中的分支预测器状态,cache等组件是一直都在更新的 在到达采样点时,分支预测器和cache等组件内部是处于更新好的状态 而直接运行checkpoint时,处理器中的状态一开始是空的,分支预测器和cache等组件都是处于初始状态 因此在运行checkpoint时,我们需要提前运行一小段程序来将处理器组件的状态变为与运行完整程序到达该采样点时的状态 这样我们才能得到更准确的性能数据 一般流程则是: warmup-&gt;开启性能计数器-&gt;运行checkpoint 实际上warmup所用的程序可以直接使用checkpoint,但不开启性能计数器 warmup 功能预热这是warmup的拓展,实际处理器在warmup的时候,可以只预热比较重要的组件 比如:分支预测器,访存依赖预测器,L1,L2Cache等 而这些组建实际上都位于处理器前端和访存模块,与后端执行组件无关 因此在warmup时,我们可以将处理器后端执行组件切换为简单模型,比如功能模型 以此来提高预热速度 在正式运行checkpoint时再将后端功能模型切换为完整模型,以此来提高精度 快速性能迭代总结使用gem5性能模拟器 使用checkpoint加快程序运行速度 使用warmup功能预热加快预热速度,同时几乎不影响性能测算精度","categories":[{"name":"处理器设计","slug":"处理器设计","permalink":"https://tastynoob.github.io/categories/%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/"}],"tags":[]},{"title":"启明星智能组暑期培训-toysoc-riscv处理器实现","slug":"RISCV/toysoc","date":"2022-08-13T16:00:00.000Z","updated":"2023-04-29T08:18:51.244Z","comments":true,"path":"2022/08/14/RISCV/toysoc/","link":"","permalink":"https://tastynoob.github.io/2022/08/14/RISCV/toysoc/","excerpt":"一个简单的教学用riscv处理器","text":"一个简单的教学用riscv处理器 仓库地址click mecoremark跑分仿真工作频率1Mhz,平均0.258Coremark&#x2F;Mhz","categories":[{"name":"处理器设计","slug":"处理器设计","permalink":"https://tastynoob.github.io/categories/%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"riscv","slug":"riscv","permalink":"https://tastynoob.github.io/tags/riscv/"}]},{"title":"使用FPGA设计的入门级基于riscv指令集的soc","slug":"RISCV/ritter-soc","date":"2022-03-07T16:00:00.000Z","updated":"2023-04-29T08:18:54.325Z","comments":true,"path":"2022/03/08/RISCV/ritter-soc/","link":"","permalink":"https://tastynoob.github.io/2022/03/08/RISCV/ritter-soc/","excerpt":"ritter-soc是我大二时期在安路EG4s平台上设计的一款基于rv32im指令集的soc可运行基本的程序，和coremark跑分","text":"ritter-soc是我大二时期在安路EG4s平台上设计的一款基于rv32im指令集的soc可运行基本的程序，和coremark跑分 ritter-soc说明介绍ritter-soc信息ritter-soc是我从大一时期到大二时期花了半年时间自研出来的基于riscv指令集的处理器里面包括ritter-core以及总线和外设所有设计均采用verilog设计该项目使用sipeed公司的tang premier FPGA开发板上开发目前ritter-soc支持完整的riscv32IM指令集并在此基础上添加了简易的浮点加速单元(FPU)能够运行完整复杂的程序 ritter-soc架构图 (仅作参考) ritter-soc工作状态工作频率:84MHZ外设:一个串口,一个计数器 (以后会慢慢更新)coremark跑分: 使用说明使用安路(anlogic)公司提供的FPGA开发软件(TD，可在sipeed公司wiki中寻找)打开project文件夹下的work-ritter_soc1.0.al文件(TD工程文件)即可打开ritter-soc的工程项目 烧录程序详细请见isa目录下的说明 注意事项编译项目之前记得更改如下几个文件1.project&#x2F;al_ip&#x2F;bram_itcm.v:更改bram填充文件地址”INIT_FILE”2.查看defines.v和config.v，根据需要修改宏定义3.在进行仿真时,注意需要导入安路的硬件仿真库(位于TD软件安装目录下的sim_release) 更新日志22&#x2F;5&#x2F;31:工作时钟频率调整为80Mhz,添加额外的串口和gpio外设,还有PWM输出,添加bootloader固件，可实现串口烧录程序,详细见isa&#x2F;文件夹下22&#x2F;3&#x2F;3: 优化了指令执行时序,版本改为v1.322&#x2F;2&#x2F;25:ritter-soc 1.0发布21&#x2F;7&#x2F;24:ritter-core 0.1发布(不推荐使用)","categories":[{"name":"处理器设计","slug":"处理器设计","permalink":"https://tastynoob.github.io/categories/%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"riscv","slug":"riscv","permalink":"https://tastynoob.github.io/tags/riscv/"}]},{"title":"简单讲解反向传播算法","slug":"算法/简单讲解反向传播算法","date":"2020-04-27T04:52:00.000Z","updated":"2023-04-28T16:56:51.174Z","comments":true,"path":"2020/04/27/算法/简单讲解反向传播算法/","link":"","permalink":"https://tastynoob.github.io/2020/04/27/%E7%AE%97%E6%B3%95/%E7%AE%80%E5%8D%95%E8%AE%B2%E8%A7%A3%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/","excerpt":"简单讲解反向传播算法","text":"简单讲解反向传播算法 反向传播算法在神经网络中站很大的地位,大多数神经网络都能用反向传播算法进行训练, 但不少初学者不容易弄懂其中的具体公式(比如说我),所以讲解公式很有必要 (这里不讲前向传播,可自行寻找相关信息) 首先先规定一些宏: 12345678910111213LS:神经网络的层数NF(n):神经网络第n层的神经元个数BF(n,a):神经网络第n层第a个神经元的偏置(输入层没有偏置)WF(n,a,p):神经网络第n层第a个神经元的第p个权重(输入层没有权重)NETF(n,a):神经网络第n层第a个神经元的加权和(wx+b)OF(n,a):神经网络的第n层第a个神经元的输出(不包括输入层,OF可有可无,有点话使用某些激活函数可方便计算)SF(n,a):神经网络的第n层第a个神经元的误差INF(n):神经网络的第n个输入OUTF(n):神经网络的第n个实际输出(即输出层第n个输出)TAF(n):神经网络的第n个理想输出(即样本输出)LN:学习率F(x):激活函数函数F_(x):激活函数的导函数 注意: 在进行反向传播之前,首先需要先前向传播一次,计算好各个层的(加权和)和输出 首先是计算输入层的误差(为了更加容易理解,这里用文字和符号表述): 123SF(LS,1) = (2.0/NF(LS))*(OUTF(1) - TAF(1))输出层第1个神经元的误差 = (2.0/输出层神经元数量)*(实际第1个输出-理想第1个输出),以此类推ps:注意这里是浮点数2.0不是整数2 更新输入层的权重和偏置: 12345678910BF(LS,1) = BF(LS,1) - LN * SF(LS,1)更新后的输出层第1个偏置 = 原偏置 - 学习率*输出层第1个误差,以此类推WF(LS,1,2) = WF(LS,1,2) - LN * SF(LS,1) * OF(LS-1,2);更新后的输出层第1个神经元的第2个权重 = 原权重 - 学习率 * 输出层第1个误差 * 上一层第2个输出作为参照:WF(n,1,4) = WF(n,1,4) - LN * SF(n+1,4) * OF(n,4);更新后的第n层第1个神经元的第4个权重 = 原权重 - 学习率 * 下一层层第4个误差 * 第n层第1个输出以此类推 然后是隐藏层的误差: 12345678910SF(n,4) = SF(n+1,1)*WF(n,4,1)*F_(NETF(n,4)) + SF(n+1,2)*WF(n,4,2)*F_(NETF(n,4)) +SF(n+1,3)*WF(n,4,3)*F_(NETF(n,4)) +...........第n层第4个神经元的误差 = 下一层第1个神经元的误差 * 第n层第4个神经元第1个权重 * 第n层的第4个神经元的导函数输出 +下一层第2个神经元的误差 * 第n层第4个神经元第2个权重 * 第n层的第4个神经元的导函数输出 +下一层第3个神经元的误差 * 第n层第4个神经元第3个权重 * 第n层的第4个神经元的导函数输出+........ps:这里之所以用计算第n层第4个神经元的误差做例,是为了更好的理解实际上就是个数学表达式:第n层的误差数组 = (下一层的误差数组*第n层的权重矩阵)*第n层的加权和的导数数组 隐藏层的误差计算 , 权重和偏置的更新与输出层一样,这里就不加赘述了 由于输入层只有输入,所以没有误差 总之,神经网络搭建完后,就可以开始训练了,导入样本,然后开始前向传播一次,反向传播一次,反复计算 其中需要计算总误差: 1234double val = 0;for (int a = 1; a &lt;= NF(LS); a++) &#123; val += ((OF(LS, a) - TAF(a)) * (OF(LS, a) - TAF(a))) / NF(LS); &#125; 至此,反向传播的大致公式就完了,具体数学原理可自行查询(资料挺多的,应该不用担心)","categories":[{"name":"人工智能","slug":"人工智能","permalink":"https://tastynoob.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"算法","slug":"算法","permalink":"https://tastynoob.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"神经网络","slug":"神经网络","permalink":"https://tastynoob.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"}]},{"title":"用纯c语言写一个完整的BP神经网络","slug":"算法/用纯c语言写一个完整的BP神经网络","date":"2020-04-22T10:13:00.000Z","updated":"2023-04-28T16:56:51.174Z","comments":true,"path":"2020/04/22/算法/用纯c语言写一个完整的BP神经网络/","link":"","permalink":"https://tastynoob.github.io/2020/04/22/%E7%AE%97%E6%B3%95/%E7%94%A8%E7%BA%AFc%E8%AF%AD%E8%A8%80%E5%86%99%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84BP%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/","excerpt":"用纯c语言写一个完整的BP神经网络","text":"用纯c语言写一个完整的BP神经网络 话不多说,直接上代码 所有的说明均在代码中 首先是头文件BPNetWork.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#ifndef BPNETWORK_H#define BPNETWORK_H//所需头文件#include&lt;math.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#define f(x) Sigmoid(x)//激活函数设定#define f_(x) Sigmoidf(x)//导函数typedef struct &#123; double* ws;//权重矩阵 double* bs;//偏置数组 double* os;//输出数组 double* ss;//误差(总误差关于加权和的偏导)&#125; Layer;typedef struct &#123; int lns;//层数 int* ns;//每层神经元的数量 double* is;//神经网络输入 double* ts;//理想输出 Layer* las;//神经网络各个层(不包括输入层) double ln;//学习率&#125;BPNetWork;//创建神经网络BPNetWork* BPCreate(int* nums, int len,double ln);//运行一次神经网络void RunOnce(BPNetWork* network);//载入训练集void LoadIn(BPNetWork* network, double* input, double* putout);//反向传播一次(训练一次)void TrainOnce(BPNetWork* network);//输出总误差double ETotal(BPNetWork* network);//sigmoid激活函数#define Sigmoid(x) (1 / (1 + exp(-(x))))//sigmoid激活函数的导函数,输入为sigmoid输出#define Sigmoidf(f) ((f) * (1 - (f)))#define Tanh(x) ((2 / (1 + exp(-2 * (x))))-1)#define Tanhf(f) ((1+(f))*(1-(f)))#endif 然后是程序本体BPNetWork.c 宏定义 123456789101112131415161718192021222324252627282930313233343536#include&quot;BPNetWork.h&quot;//神经网络的层数#define LS network-&gt;lns//输入层神经元的数量#define INNS network-&gt;ns[0]//输入层的第a个输入#define INS(a) network-&gt;is[a-1]//第a个理想输出#define TAS(a) network-&gt;ts[a-1]//输出层神经元的数量#define OUTNS network-&gt;ns[LS-1]//第n层神经元的数量#define NS(n) network-&gt;ns[n-1]//第n层第a个神经元的第p个权重#define WF(n,a,p) network-&gt;las[n-2].ws[(p-1)+(a-1)*NS(n-1)]//第n层的第a个神经元的偏置#define BF(n,a) network-&gt;las[n-2].bs[a-1]//第n层第a个神经元的输出#define OF(n,a) network-&gt;las[n-2].os[a-1]//第n层第a个神经元的误差#define SF(n,a) network-&gt;las[n-2].ss[a-1]//学习率#define LN network-&gt;ln BPCreate函数: 123456789101112131415161718192021222324252627282930313233BPNetWork* BPCreate(int* nums, int len,double ln)&#123; BPNetWork* network = malloc(sizeof(BPNetWork)); network-&gt;lns = len; network-&gt;ns = malloc(len * sizeof(int)); network-&gt;ln = ln; memcpy(network-&gt;ns, nums, len * sizeof(int)); // network-&gt;is = malloc(nums[0] * sizeof(double)); network-&gt;las = malloc(sizeof(Layer) * (len - 1)); network-&gt;ts = malloc(sizeof(double) * nums[len - 1]); srand(&amp;network);//用networkd的内存地址做为随机数种子 for (int p = 0; p &lt; len - 1; p++) &#123; int lastnum = nums[p];//上一层的神经元数量 int num = nums[p + 1];//当前层的神经元数量 network-&gt;las[p].bs = malloc(sizeof(double) * num); // network-&gt;las[p].ws = malloc(sizeof(double) * num * lastnum); // network-&gt;las[p].os = malloc(sizeof(double) * num); // network-&gt;las[p].ss = malloc(sizeof(double) * num); for (int pp = 0; pp &lt; num; pp++) &#123; //这里rand()/2.0的意思是把整数除整数转换为浮点数除整数 //如果是整数除整数,输出则为带余的商 network-&gt;las[p].bs[pp] = rand() / 2.0 / RAND_MAX; for (int ppp = 0; ppp &lt; lastnum; ppp++) &#123; network-&gt;las[p].ws[ppp + pp * lastnum] = rand() / 2.0 / RAND_MAX; &#125; &#125; &#125; return network;&#125; RunOnce函数: 123456789101112131415161718192021void RunOnce(BPNetWork* network) &#123; //计算输入层到第二层 for (int a = 1; a &lt;= NS(2); a++) &#123; double net = 0; double* o = &amp;OF(2,a);//获取第2层的输出值for (int aa = 1; aa &lt;= INNS; aa++) &#123; net += INS(aa) * WF(2, a, aa);//INS(aa) * WF(2, a, aa); &#125; *o = f(net + BF(2,a)); &#125; for (int n = 2; n &lt;= LS-1; n++) &#123; for (int a = 1; a &lt;= NS(n + 1); a++) &#123;//下一层的神经网络 double net = 0; double* o = &amp;OF(n+1,a);for (int aa = 1; aa &lt;= NS(n); aa++) &#123;//当前层的神经网络 double oo = OF(n, aa); double* ww = &amp;WF(n + 1, a, aa); net += oo * (*ww); &#125; *o = f(net + BF(n + 1, a)); &#125; &#125;&#125; TrainOnce函数: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657void TrainOnce(BPNetWork* network) &#123; //计算输出层的误差函数 for (int a = 1; a &lt;= OUTNS; a++) &#123; double* s = &amp;SF(LS,a);//获取第a个神经元的误差double* b = &amp;BF(LS, a);//获取第a个神经元的偏置 double o = OF(LS, a);//获取第a个神经元的输出 *s = (2.0 / OUTNS) * (o - TAS(a))* f_(o); *b = *b - LN * (*s);//更新偏置 //更新权重 for (int aa = 1; aa &lt;=NS(LS-1) ; aa++) &#123; double* w = &amp;WF(LS, a, aa); *w = *w - LN * (*s) * OF(LS-1, aa); &#125; &#125; //计算隐藏层的误差 for (int a = LS-1; a &gt; 2; a--) &#123; //开始计算第a层每个神经元的误差 for (int n = 1; n &lt;= NS(a); n++) &#123;//当前层 double* s = &amp;SF(a, n);//获取第a个神经元的误差 *s = 0; double* b = &amp;BF(a, n);//获取第a个神经元的偏置 double o = OF(a, n);//获取第a个神经元的输出 for (int nn = 1; nn &lt;= NS(a+1); nn++) &#123;//下一层 double lw = WF(a + 1, nn, n);//获取下一层到当前神经元的偏置 double ls = SF(a + 1, nn);//获取下一层第nn个神经元的误差 *s += ls * lw * f_(o); &#125; *b = *b - LN * (*s);//更新偏置 //更新权重 for (int nn = 1; nn &lt;= NS(a - 1); nn++) &#123;//上一层 double* w = &amp;WF(a, n, nn); *w = *w - LN * (*s) *OF(a - 1, nn); &#125; &#125; &#125; //计算第2层的误差函数 for (int n = 1; n &lt;= NS(2); n++) &#123;//当前层 double* s = &amp;SF(2, n);//获取第a个神经元的误差 *s = 0; double* b = &amp;BF(2, n);//获取第a个神经元的偏置 double o = OF(2, n);//获取第a个神经元的输出 for (int nn = 1; nn &lt;= NS(3); nn++) &#123;//下一层 double lw = WF(3, nn, n);//获取下一层到当前神经元的偏置 double ls = SF(3, nn);//获取下一层第nn个神经元的误差 *s += ls * lw * f_(o); &#125; *b = *b - LN * (*s);//更新偏置 //更新权重 for (int nn = 1; nn &lt;= INNS; nn++) &#123;//上一层 double* w = &amp;WF(2, n, nn); *w = *w - LN * (*s) * INS(nn); &#125; &#125; &#125; LoadIn函数: 1234void LoadIn(BPNetWork* network,double* input,double* putout) &#123; memcpy(network-&gt;is, input, INNS*sizeof(double)); memcpy(network-&gt;ts, putout, OUTNS*sizeof(double));&#125; ETotal函数: 1234567double ETotal(BPNetWork* network) &#123; double val = 0; for (int a = 1; a &lt;= OUTNS; a++) &#123; val += ((OF(LS, a) - TAS(a)) * (OF(LS, a) - TAS(a))) / OUTNS; &#125; return val;&#125; 入口函数: 12345678910111213141516171819202122232425262728293031int main() &#123; int a[] = &#123; 1,20,20,1 &#125;;//4层神经元,数量分别为1,20,20,1 double in[1] = &#123; 0.9 &#125;;//训练样本输入1 double in1[1] = &#123; 0.1 &#125;;//训练样本输入2 double in2[1] = &#123; 0.5 &#125;;//训练样本输入3 double out[1] = &#123; 0.1 &#125;;//理想输出 //神经网络训练目标: //输入任意值,输出0.1 BPNetWork* network = BPCreate(a, 4, 0.5); int c = 1000;//训练1000次 while (c--) &#123; LoadIn(network, in, out); RunOnce(network); TrainOnce(network); LoadIn(network, in1, out); RunOnce(network); TrainOnce(network); LoadIn(network, in2, out); RunOnce(network); TrainOnce(network); &#125; //训练完后来一波测试 double t[1] = &#123; 0.7 &#125;;//输入 double o[1] = &#123; 0.2 &#125;;//凑数 LoadIn(network, t, o); RunOnce(network); printf(&quot;OK\\n&quot;); printf(&quot;%g\\n&quot;, ETotal(network)); printf(&quot;%g&quot;, OF(4, 1)); return 0;&#125; 训练目标: 输入任意数,输出总为0.1 经过1000次训练后的输出: 123OK0.0101097//最终误差0.0994528//输入0.7,输出约为0.1","categories":[{"name":"人工智能","slug":"人工智能","permalink":"https://tastynoob.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"算法","slug":"算法","permalink":"https://tastynoob.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"神经网络","slug":"神经网络","permalink":"https://tastynoob.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"}]},{"title":"GD32V运行速度慢的解决方法","slug":"GD32V运行速度慢的解决方法","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.121Z","comments":true,"path":"1970/01/01/GD32V运行速度慢的解决方法/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/GD32V%E8%BF%90%E8%A1%8C%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","excerpt":"使用longan mcu时，出现了延时1s却实际上感觉延时了5s左右 这个问题实际上是由于官方提供的时钟初始化函数没有执行","text":"使用longan mcu时，出现了延时1s却实际上感觉延时了5s左右 这个问题实际上是由于官方提供的时钟初始化函数没有执行 导致核心频率达不到全频108MHz，出现定时器延时错误 我们只需要把该功能开启即可 找到该函数_init() 1234567891011121314151617181920212223void _init()&#123; SystemInit(); //ECLIC init eclic_init(ECLIC_NUM_INTERRUPTS); eclic_mode_enable(); //printf(&quot;After ECLIC mode enabled, the mtvec value is %x \\n\\n\\r&quot;, read_csr(mtvec)); // // It must be NOTED: // // * In the RISC-V arch, if user mode and PMP supported, then by default if PMP is not configured // // with valid entries, then user mode cannot access any memory, and cannot execute any instructions. // // * So if switch to user-mode and still want to continue, then you must configure PMP first //pmp_open_all_space(); //switch_m2u_mode(); /* Before enter into main, add the cycle/instret disable by default to save power, only use them when needed to measure the cycle/instret */ disable_mcycle_minstret();&#125; 在主函数开头里调用该函数即可","categories":[{"name":"其它","slug":"其它","permalink":"https://tastynoob.github.io/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"riscv","slug":"riscv","permalink":"https://tastynoob.github.io/tags/riscv/"}]},{"title":"arm汇编汇总","slug":"arm","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.123Z","comments":true,"path":"1970/01/01/arm/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/arm/","excerpt":"当初学stm32时因为一个想法，然后就走入了arm汇编的世界，这里就来汇总一下。","text":"当初学stm32时因为一个想法，然后就走入了arm汇编的世界，这里就来汇总一下。 stm32的arm处理一般有7个运行模式，分别为： ​ ① 用户模式（USR）： 用于正常执行程序（The normal ARM program execution state） ​ ② 快速中断模式（FIQ）： 用于高速数据传输（Designed to support a data transfer or channel process） ​ ③ 外部中断模式（IRQ）： 用于通常的中断处理（Used for general-purpose interrupt handling） ​ ④ 管理模式（SVC）： 操作系统使用的保护模式（Protected mode for the operating system） ​ ⑤ 数据访问终止模式（ABT）： 当数据或指令预取终止时进入该模式（Entered after a data or instruction prefetch abort） ​ ⑥ 系统模式（SYS）： 运行具有特权的操作系统任务（A privileged user mode for the operating system）&gt; ​ ⑦ 未定义指令异常模式（UND）： 当未定义的指令执行时进入该模式（Entered when an undefined instruction is executed） &lt;&gt;注：ARM微处理器的运行模式可以通过软件改变（修改CPSR后5位），也可以通过中断或者异常处理改变 每个运行模式下访问的寄存器都有一定的区别 在ARM处理器内部共有37个用户可访问的寄存器，分别为 31个通用的32位寄存器和6个状态寄存器 其中的特殊寄存器：r14：lr寄存器，用来保存pc值r13：sp寄存器，栈顶寄存器 常用指令: 123456789101112131415161718192021mov r0,r1 ;r0 = r1mov r0,#0x1 ;r0 = 0x1mov r0,r1,lsl #3 ;r0 = r1&lt;&lt;3 逻辑左移(asl算数左移)mov r0,r1,lsr #3 ;r0 = r1&gt;&gt;3 逻辑右移,高位补0 (asr算数右移，高位补符号位)ldr r0,[r1] ;将r1对应的指针指向的值存入r0str r0,[r1] ;将r0存入r1对应的指针指向的地址;比较指令cmp r0,r1 ;将r0与r1的值相减，并根据结果设置cpsr的标志位cmp r0,#100；将r0与100相减，并根据结果设置cpsr的标志位tst r0,r1 ;把r0的内容和r1的内容或立即数进行按位的与运算，并根据运算结果更新CPSR中条件标志位的值。;运算指令add r0,r1,r2 ;R0 = R1 + R2add r0,r1,#256 ;R0 = R1 + 256add r0,r2,r3,lsl#1 ;R0 = R2 + (R3 &lt;&lt; 1)orr r0,r1,r2 ;将r1与r2或立即数做或按位运算并放入r0;跳转指令b label ;直接跳转到label处bl label ;直接跳转到label处，并将当前的pc值存入r14;伪指令push &#123;r0&#125; ;压栈入栈,注意stm32压栈为向下压栈,即sp=sp-4pop &#123;r0&#125; PS: “#0x1”是立即数，立即数是指，能够用0-255之内的数据循环右移偶数位得到的数 判断规则如下： 把数据转换成二进制形式，从低位到高位写成4位1组的形式，最高位一组不够4位的，在最高位前面补0。 数1的个数，如果大于8个肯定不是立即数，如果小于等于8进行下面步骤。 如果数据中间有连续的大于等于24个0,循环左移2的倍数，使高位全为0。 找到最高位的1，去掉前面最大偶数个0。 找到最低位的1，去掉后面最大偶数个0。 数剩下的位数，如果小于等于8位，那么这个数就是立即数，反之就不是立即数。 函数调用规则: 函数调用时会执行“BL func”指令 函数参数传递通过r0~r4寄存器，多余参数通过栈传递 进入函数后会执行一条“push {lr}”指令(根据不同情况，会压入其它寄存器) 退出函数时通过r0返回结果，并执行“pop {pc}”(根据不同情况，会弹出其它值到另外的寄存器)","categories":[{"name":"其它","slug":"其它","permalink":"https://tastynoob.github.io/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"arm","slug":"arm","permalink":"https://tastynoob.github.io/tags/arm/"}]},{"title":"k210时钟树讲解","slug":"k210时钟树讲解","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.124Z","comments":true,"path":"1970/01/01/k210时钟树讲解/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/k210%E6%97%B6%E9%92%9F%E6%A0%91%E8%AE%B2%E8%A7%A3/","excerpt":"k210时钟树讲解","text":"k210时钟树讲解 首先来看看完整的k210时钟树 看着很复杂对吧，我们来一步一步分析看看 k210 总共有3个PLL倍频器 PLL0为内核和大部分外设提供时钟 PLL1为AI提供时钟 PLL2为I2S提供时钟 每个PLL内部分别经过： CLKR（1~16）分频，CLKF（1~64）倍频，CLKOD（1~16）分频 输出时钟 先来看看PLL0 PLL0是最复杂的一部分 首先，外部26M晶振连入PLL0和ACLK MUX时钟选择器 PLL0由”PLL0 OUT EN“信号使能输出 PLL0时钟连入ACLK分频器，ACLK（2,4,8,16）分频器连入ACLK MUX时钟选择 通过控制”ACLK SEL“信号可选择ALCK时钟是PLL0输入还是26M晶振输入 ACLK时钟才是实际上为内核和大部分外设提供的时钟 由图可以看到 ACLK时钟直接给CPU，DMA，SPI3，FFT,SRAM0,SRAM1提供时钟 ACLK下挂载着APB0~APB2和DVP，ROM这5个分频器 APB分频器可以提供1~8的分频 每个分频器都有一个与之对应的使能信号 再来看看外设的一部分 每个APB总线可单独堆ACLK分频，分频系数为1~8 每个APB总线都有个“CLK EN GROUP” 时钟使能组 意思是每个APB总线上挂载的外设都有个与之对应的时钟使能信号 APB0上是常用的GPIO，UART，SPI等外设时钟 这里要注意一下，看到APB外设组旁边的几根虚线没？ 这个连接的是一些特殊外设，包括TIMER，I2C，SPI，I2S，WDT， 它们的时钟实际上由专用的分频器提供 这意味这这几个外设可以更加灵活的在不同频率下工作而不会收到APB时钟影响 初此之外，APB1时钟还连接着OPT MUX时钟选择器 OPT MUX时钟选择器还可以选择由外部晶振经过2分频后的时钟 APB1同时通过一个分频器组“APB1 CLK TH”输出APB1时钟 下面来看看这些特殊外设 这里每个分频器都是分频器组 都可以单独为这些外设SPI0，SPI1…TIMER0，TIMER1… 提供2~512的分频 其中还有个更特殊的外设SPI3 它有独立的时钟选择器，时钟非输出，2路SPI时钟输出 最下面还有RTC时钟，直接由外部晶振提供 最上面就则是PLL1和PLL2 PLL1经过“AI GCLK TH”分频器给AI提供时钟 PLL2输入为MUX时钟选择器，可以由PLL1，PLL0和外部晶振提供输入 PLL2提供I2S高精度时钟 因此，在实际裸机开发时要注意时钟的管理 可能会由于调整cpu频率而导致其它外设无法工作的情况 例如在PLL0频率达到600MHz的情况下使用SPI0设备 如果不对SPI0分频器进行分频，就有会导致SPI0时钟过大 k210时钟由“sysctl”寄存器组进行控制 时钟主要由这几个寄存器控制 PLL0，PLL1，PLL12 控制寄存器 时钟选择0、1寄存器 时钟频率设置0~6寄存器 由于寄存器设置位太多，这里不详细介绍 详细可参考k210寄存器手册","categories":[{"name":"其它","slug":"其它","permalink":"https://tastynoob.github.io/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"k210","slug":"k210","permalink":"https://tastynoob.github.io/tags/k210/"}]},{"title":"vscode上的linux远程开发配置","slug":"linux_ssh","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.132Z","comments":true,"path":"1970/01/01/linux_ssh/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/linux_ssh/","excerpt":"1234无","text":"1234无 在利用ssh进行远程开发时 如果要查看远程的图像或者摄像头时 就会无法显示 比如在远程开发opencv时 就会无法查看opencv的窗口 但是我们希望在远程开发时 远程的窗口也能在本地显示 这样就方便了开发和调试 这里我们使用vscode的remote插件进行远程开发 不光可以显示图片，还可以显示和控制图形程序 首先你要在vscode上安装remote ssh和remote x11插件 并能进行免密登录远程服务器 我们来尝试使用windows本地主力机连接远程linux服务器进行远程开发 首先是ssh的配置，确保你拥有openssh并开启了ssh服务 客户端(windows)和服务端(linux)都需要开启 windows下： windows我们需要生成本地的ssh密匙 打开命令行，输入ssh-keygen,回车 然后他会让你配置密码，我们要免密登录所以直接回车，不配置密码 后面需要回车三次，如果最后输出一段奇怪字符就代表生成成功 打开user&#x2F;.ssh文件夹，就能看到以下文件 其中id_rsa.pub就是你的公匙，可以用该公匙实现远程免密登录 linux下： linux服务端需要允许外部ssh连接 先提前在linux上配置好相关配置 假如你windows远程需要登录服务器上的user用户 在linux上登录user账号 打开终端 输入sudo vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config 找到如图的2项 默认情况下这两项是被注释掉的 将这两项取消注释即可 .ssh&#x2F;authorized_keys这个是你的外部密匙保存文件 如果你是使用user用户，那么该文件应该就是user&#x2F;.ssh&#x2F;authorized_keys 继续终端输入 cd ~&#x2F;.ssh 输入vim authorized_keys 将在windows上的密匙文件id_rsa.pub里面的内容复制到authorized_keys文件里 保险期间我们一般是先把id_rsa.pub复制到user&#x2F;.ssh&#x2F;文件夹下 然后使用cat id_rsa.pub &gt;&gt; authorized_keys id_rsa.pub里面的内容复制到authorized_keys文件里 然后重启ssh服务service sshd restart 接下来在vscode这边安装好remote ssh和remote x11 打开侧边栏的“远程资源管理器” 这里我是已经配置好2个远程开发环境了 点击右上角的设置,弹出一个选择框,选择第一个 其中：Host是远程服务器的名称，可自定义 HostName是远程服务器IP地址或者网址,必须要填对 Port是远程服务器ssh端口，默认为22 User是你要登录远程服务器的账号，必须要填对，你要使用user账号就填user 另外最下面的3个选项是远程服务器的窗体映射开启 开启这三个选项就能实现远程窗口在本地显示 比如想在远程服务器上显示图片，那么在本地就能生成一个窗口显示远程图片 开启x11还需要安装X server 本地需要下载并安装Xlaunch软件 这个可自行搜索下载 以上设置配置好后， 就可以右键远程资源窗口里的远程服务器进行连接 如图已连接上远程服务器 接下来就可以开始愉快的开发了 由于强大的vscode支持，远程开发十分顺滑，比远程桌面更好用 最后再来说一下Xlaunch的用法 打开Xlaunch软件，它会提示你设置窗口界面，直接下一步即可 然后在远程服务器上也要安装remote x11插件 如图选择在SSH:user上安装即可 安装完成后以防万一重启次服务器和vscode 接下来确保x11服务开启，XLaunch开启 在远程服务器上打开一个图片 如果无误，那么本地就会出现一个窗口，里面显示你选择的图片 X11也可以用来显示图形化软件，opencv等窗口，比远程桌面响应更快，延迟更小","categories":[{"name":"linux","slug":"linux","permalink":"https://tastynoob.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://tastynoob.github.io/tags/linux/"}]},{"title":"基于gd32vf的真·多线程系统","slug":"longan thread","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.132Z","comments":true,"path":"1970/01/01/longan thread/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/longan%20thread/","excerpt":"基于gd32vf的真·多线程系统","text":"基于gd32vf的真·多线程系统 目前应用于嵌入式系统的操作系统一般都是 实时多任务操作系统，实际上算是伪多线程 只有当你明确的调用任务delay函数时才会发生调度 以前想设计一个真·多线程操作系统 但是在stm32平台上开发的，由于cm3内核的封闭性，无法明确的修改关键寄存器 但是在riscv上则可以实现，riscv明确了几种中断触发方式 利用自定义中断处理函数可以实现对关键寄存器进行修改，从而达到切换线程的目的 下面是gd32v的中断入口 这里使用定时器6作为线程调度时钟，时间设置为1ms中断 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111 .section .text.irq .align 2 .global irq_entry.weak irq_entryirq_entry: // -------------&gt; This label will be set to MTVT2 register // Allocate the stack space //保存现场 SAVE_CONTEXT// Save 16 regs //------This special CSR read operation, which is actually use mcause as operand to directly store it to memory csrrwi x0, CSR_PUSHMCAUSE, 17 //------This special CSR read operation, which is actually use mepc as operand to directly store it to memory csrrwi x0, CSR_PUSHMEPC, 18 //------This special CSR read operation, which is actually use Msubm as operand to directly store it to memory csrrwi x0, CSR_PUSHMSUBM, 19 service_loop: //------This special CSR read/write operation, which is actually Claim the CLIC to find its pending highest // ID, if the ID is not 0, then automatically enable the mstatus.MIE, and jump to its vector-entry-label, and // update the link register csrrw ra, CSR_JALMNXTI, ra //RESTORE_CONTEXT_EXCPT_X5 //恢复现场 #---- Critical section with interrupts disabled ----------------------- DISABLE_MIE # Disable interrupts LOAD x5, 19*REGBYTES(sp) csrw CSR_MSUBM, x5 LOAD x5, 18*REGBYTES(sp) csrw CSR_MEPC, x5 LOAD x5, 17*REGBYTES(sp) csrw CSR_MCAUSE, x5 RESTORE_CONTEXT // Return to regular code mret.global TIMER6_IRQHandler//定时器六中断，作为线程切换中断TIMER6_IRQHandler: //保存x18~x27寄存器,s1 addi sp, sp, -11*REGBYTES STORE x27, 0*REGBYTES(sp) STORE x26, 1*REGBYTES(sp) STORE x25, 2*REGBYTES(sp) STORE x24, 3*REGBYTES(sp) STORE x23, 4*REGBYTES(sp) STORE x22, 5*REGBYTES(sp) STORE x21, 6*REGBYTES(sp) STORE x20, 7*REGBYTES(sp) STORE x19, 8*REGBYTES(sp) STORE x18, 9*REGBYTES(sp) STORE x9, 10*REGBYTES(sp) mv a0,sp //sp mv a1,s0 //fp addi sp,sp,-4 sw ra,0(sp) call switch_thread lw ra,0(sp) addi sp,sp,4 mv sp,x30 //切换sp mv s0,x31 //切换fp //还原x18~x27寄存器,s1 LOAD x27, 0*REGBYTES(sp) LOAD x26, 1*REGBYTES(sp) LOAD x25, 2*REGBYTES(sp) LOAD x24, 3*REGBYTES(sp) LOAD x23, 4*REGBYTES(sp) LOAD x22, 5*REGBYTES(sp) LOAD x21, 6*REGBYTES(sp) LOAD x20, 7*REGBYTES(sp) LOAD x19, 8*REGBYTES(sp) LOAD x18, 9*REGBYTES(sp) LOAD x9, 10*REGBYTES(sp) addi sp, sp, 11*REGBYTES //清空计数器 lui a0,0x40001 addi a1,a0,1060 sw zero,0(a1) //清除中断标志位 addi a1,a0,1040 li a2,-2 sw a2,0(a1) ret 下面是线程切换的关键代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#ifndef THREAD_H#define THREAD_H#include &quot;config.h&quot;#include &quot;myalloc.h&quot;#include &quot;systick.h&quot;//最大可用线程数#define max_thread_num 5typedef void(*Func)();typedef struct &#123; volatile int sp; volatile int fp; volatile int* stack; volatile int wait_tick;//等待tick volatile int available;//是否激活 volatile int pri;//运行优先级 volatile int re_pri;//重装载优先级,每当一个线程运行完毕就会重置pri&#125;Thread;extern volatile int thd_flag;extern volatile int thd_ptr;extern Thread thds[max_thread_num];//线程初始化void thread_init();//线程创建Thread* thread_creat(Func func, int stack_size, int level);void thread_release(Thread* thd);//线程释放//线程睡眠void thread_sleep_tick(int tick);//线程开启调度void thread_start();//在进行一些不可分割操作时，调用该函数进行暂停线程调度//关闭定时器中断 //停止计数#define thd_stop do&#123;\\if (thd_flag == 1)\\&#123;\\TIMER_DMAINTEN(TIMER6) &amp;= (~(uint32_t)TIMER_INT_UP); \\&#125;\\&#125;while (0)//在进行一些不可分割操作时，调用该函数进行继续线程调度//开启定时器中断//继续计数#define thd_cont do&#123;\\if (thd_flag == 1)\\&#123; \\TIMER_DMAINTEN(TIMER6) |= (uint32_t)TIMER_INT_UP; \\&#125;\\&#125;while (0)#endif // !THREAD_H 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195#include &quot;thread.h&quot;int thd_num = 1;Thread thds[max_thread_num];//当前线程指针volatile int thd_ptr = 0;volatile int thd_flag = 0;/*线程调度说明：每个线程都有一个基础等级,等级越大执行概率越低基础等级 = level每个线程运行一次则增加1点等级其它可用但未执行的线程等级-1*///线程初始化void thread_init() &#123; for (int i = 0;i &lt; max_thread_num;i++) &#123; thds[i].fp = 0; thds[i].sp = 0; thds[i].stack = 0; thds[i].wait_tick = 0; thds[i].available = 0; &#125; //主线程,主线程优先级为2 thds[0].available = 1; thds[0].wait_tick = 0; thds[0].pri = 2; thds[0].re_pri = 2;&#125;//线程创建Thread* thread_creat(Func func, int stack_size, int level) &#123; thd_stop; for (int i = 0;i &lt; max_thread_num;i++) &#123; if (thds[i].available == 0) &#123; thds[i].stack = myalloc(stack_size); int stack_dep = (stack_size - 1) / 4; //设置栈和栈帧 thds[i].sp = (int)&amp;(thds[i].stack[stack_dep - 31]); thds[i].fp = (int)&amp;(thds[i].stack[stack_dep]); //msubm所在位置 thds[i].stack[stack_dep - 31 + 11 + 19] = 64; //mecp所在位置 thds[i].stack[stack_dep - 31 + 11 + 18] = (int)func; //mcause所在位置 thds[i].stack[stack_dep - 31 + 11 + 17] = -1207959478; //x1所在位置 thds[i].stack[stack_dep - 31 + 11 + 0] = (int)func; thds[i].available = 1; thds[i].pri = level; thds[i].re_pri = level; return &amp;thds[i]; &#125; &#125; thd_cont; return NULL;&#125;//线程释放inline void thread_release(Thread* thd) &#123; thd_stop; thd-&gt;available = 0; myfree((void*)thd-&gt;stack); thd_cont;&#125;//线程睡眠,并手动触发中断void thread_sleep_tick(int tick) &#123; thds[thd_ptr].wait_tick = tick; //等待中断 asm volatile(&quot;wfi&quot;);&#125;//线程开启调度void thread_start() &#123; thd_flag = 1; //清除标志位 TIMER_INTF(TIMER6) = (~1); //开启时钟 TIMER_CTL0(TIMER6) |= (uint32_t)TIMER_CTL0_CEN; //关闭时钟 //TIMER_CTL0(TIMER6) &amp;= ~(uint32_t)TIMER_CTL0_CEN;&#125;volatile int thds_temp[max_thread_num];//线程切换，由中断程序进行调用void switch_thread(int sp, int fp) &#123; //保存上次中断处的sp、fp thds[thd_ptr].sp = sp; thds[thd_ptr].fp = fp; int temp_head = 0; int thd_vld = 0; while (1) &#123; // int p; // asm volatile(&quot;mv %0,sp&quot;:&quot;=r&quot;(p) : ); //printf(&quot;sp%d\\n\\n&quot;, thds[thd_ptr].wait_tick); for (int i = 0;i &lt; max_thread_num;i++) &#123; if (thds[i].available) &#123; if (thds[i].wait_tick &lt; 1) &#123; thds_temp[temp_head++] = i;//寻找是否有空闲线程,如果有，则保存线程索引 thd_vld = 1; &#125; else &#123;//对于非空闲线程 thds[i].wait_tick--;//每个线程的等待时间-1ms &#125; &#125; &#125; //printf(&quot;dd\\n\\n&quot;); if (thd_vld)break; delayms(1);//如果没有空闲线程，则等待1ms &#125; //对可用线程的等级进行从小到大排序 for (int i = 0;i &lt; temp_head - 1;i++) &#123; for (int j = 0;j &lt; temp_head - 1 - i;j++) &#123; if (thds[thds_temp[j]].pri &gt; thds[thds_temp[j + 1]].pri) &#123; int t = thds_temp[j]; thds_temp[j] = thds_temp[j + 1]; thds_temp[j + 1] = t; &#125; else if (thds[thds_temp[j]].pri == thds[thds_temp[j + 1]].pri) &#123; if (mtime_hi() % 2) &#123;//如果有相同的则随机交换 int t = thds_temp[j]; thds_temp[j] = thds_temp[j + 1]; thds_temp[j + 1] = t; &#125; &#125; &#125; &#125; //取出栈顶索引 thd_ptr = thds_temp[0]; //当前线程被执行，重新设置优先级 thds[thd_ptr].pri = thds[thd_ptr].re_pri; //其它未执行的线程优先级增加 for (int i = 1;i &lt; temp_head;i++) &#123; thds[thds_temp[i]].pri--; &#125; //printf(&quot;p%d\\n\\n&quot;, thd_ptr); //切换到选中的线程 asm volatile(&quot;mv x30,%0&quot;::&quot;r&quot;(thds[thd_ptr].sp)); asm volatile(&quot;mv x31,%0&quot;::&quot;r&quot;(thds[thd_ptr].fp));&#125; 由于只是简单的实验，所以线程调度并没有采用复杂的算法 仅做参考 完整项目点我","categories":[{"name":"其它","slug":"其它","permalink":"https://tastynoob.github.io/categories/%E5%85%B6%E5%AE%83/"},{"name":"框架","slug":"框架","permalink":"https://tastynoob.github.io/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"riscv","slug":"riscv","permalink":"https://tastynoob.github.io/tags/riscv/"},{"name":"系统","slug":"系统","permalink":"https://tastynoob.github.io/tags/%E7%B3%BB%E7%BB%9F/"}]},{"title":"longan-gd32v vscode环境配置","slug":"longan1","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.132Z","comments":true,"path":"1970/01/01/longan1/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/longan1/","excerpt":"longan-gd32v vscode环境配置","text":"longan-gd32v vscode环境配置 首先你要在vscode官网下载vscode最新版 安装完成后，点击右侧的插件栏 搜索 “EIDE” 插件 点击安装即可，第一次使用可能需要.net环境支持 另外还需要辅助插件 “c&#x2F;c++”,搜索安装即可 重启vscode vscode侧边栏就会出现eide图标，点击 你需要指定编译器才能实现对项目的编译如果你没有选择任何工具链，那么“设置工具链路径”的图标是一个红色叉叉点击设置工具链路径它会要求你选择如下编译器根据自己的实际情况来选择编译器路径这里我们选择设置riscv gcc路径 gd32 gcc工具链可以在此地址下载 下载xpack-riscv-none-embed-gcc工具链 解压 在eide插件里选择riscv工具链路径 路径即riscv gcc安装根目录 接下来我们来新建项目 EIDE插件已经为你提前准备好了longan gd32v的开发模板 在EIDE插件中选择新建项目 选择内置项目模板，往下拉 选择新建gd32vf项目模板 如果配置无误，即可看到1如下界面 按下F7进行编译 点击侧边栏EIDE插件，就可以看到当前项目的信息 ![_&#96;RU_VE_4BN7_6PB0__XSJK.png](https://i.loli.net/2021/06/17/LYx9hUIPpbfjslg.png) 你可对该项目的头文件包含路径，源文件包含路径进行更改 接下来就可以开始愉快的开发了","categories":[{"name":"其它","slug":"其它","permalink":"https://tastynoob.github.io/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"riscv","slug":"riscv","permalink":"https://tastynoob.github.io/tags/riscv/"},{"name":"vscode","slug":"vscode","permalink":"https://tastynoob.github.io/tags/vscode/"}]},{"title":"博客测试","slug":"test","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.132Z","comments":true,"path":"1970/01/01/test/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/test/","excerpt":"第一次写博客，这篇博客就当个测试，调试了一天才调好的，也算是做个纪念","text":"第一次写博客，这篇博客就当个测试，调试了一天才调好的，也算是做个纪念 1234#include &lt;stdio.h&gt;int main()&#123; printf(&quot;hello blog!&quot;);&#125;","categories":[],"tags":[{"name":"test","slug":"test","permalink":"https://tastynoob.github.io/tags/test/"}]},{"title":"神经网络风格迁移","slug":"图像风格迁移","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.164Z","comments":true,"path":"1970/01/01/图像风格迁移/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/%E5%9B%BE%E5%83%8F%E9%A3%8E%E6%A0%BC%E8%BF%81%E7%A7%BB/","excerpt":"高中时玩人工智能发现的很有意思的东西","text":"高中时玩人工智能发现的很有意思的东西 代码基于tensorflow官方文档，上代码！需要使用VGG19tensorflow2.0以上 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188from __future__ import absolute_import, division, print_function, unicode_literalsimport tensorflow as tfimport matplotlib.pyplot as pltimport matplotlib as mplfrom tqdm import trangesteps = 100style_weight = 1e-2content_weight = 1e4total_variation_weight = 1e8mpl.rcParams[&#x27;figure.figsize&#x27;] = (13, 10)mpl.rcParams[&#x27;axes.grid&#x27;] = False# 获取下载后本地图片的路径，content_path是真实照片，style_path是风格图片content_path = &#x27;content.jpg&#x27;style_path = &#x27;style.jpg&#x27;# 读取一张图片，并做预处理def load_img(path_to_img): max_dim = 600 # 读取二进制文件 img = tf.io.read_file(path_to_img) # 做JPEG解码，得到宽x高x色深矩阵，范围0-255 img = tf.image.decode_jpeg(img) # 类型从int转换到32位浮点，数值范围0-1 img = tf.image.convert_image_dtype(img, tf.float32) # 减掉最后色深一维，获取到的相当于图片尺寸（整数），转为浮点 shape = tf.cast(tf.shape(img)[:-1], tf.float32) # 获取图片长端 long = max(shape) # 以长端为比例缩放 scale = max_dim/long new_shape = tf.cast(shape*scale, tf.int32) # 实际缩放图片 img = tf.image.resize(img, new_shape) # 再扩展一维，成为图片数字中的一张图片（1，长，宽，色深） img = img[tf.newaxis, :] return img# 读入两张图片content_image = load_img(content_path)style_image = load_img(style_path)############################################################# 定义最能代表内容特征的网络层content_layers = [&#x27;block5_conv2&#x27;] # 定义最能代表风格特征的网络层style_layers = [&#x27;block1_conv1&#x27;, &#x27;block2_conv1&#x27;, &#x27;block3_conv1&#x27;, &#x27;block4_conv1&#x27;, &#x27;block5_conv1&#x27;]# 神经网络层的数量num_content_layers = len(content_layers)num_style_layers = len(style_layers)# 定义一个工具函数，帮助建立得到特定中间层输出结果的新模型def vgg_layers(layer_names): &quot;&quot;&quot; Creates a vgg model that returns a list of intermediate output values.&quot;&quot;&quot; # 定义使用ImageNet数据训练的vgg19网络 vgg = tf.keras.applications.VGG19(include_top=False, weights=&#x27;imagenet&#x27;) # 已经经过了训练，所以锁定各项参数避免再次训练 vgg.trainable = False # 获取所需层的输出结果 outputs = [vgg.get_layer(name).output for name in layer_names] # 最终返回结果是一个模型，输入是图片，输出为所需的中间层输出 model = tf.keras.Model([vgg.input], outputs) return modeldef gram_matrix(input_tensor): result = tf.linalg.einsum(&#x27;bijc,bijd-&gt;bcd&#x27;, input_tensor, input_tensor) input_shape = tf.shape(input_tensor) num_locations = tf.cast(input_shape[1]*input_shape[2], tf.float32) return result/(num_locations)# 自定义keras模型class StyleContentModel(tf.keras.models.Model): def __init__(self, style_layers, content_layers): super(StyleContentModel, self).__init__() # 自己的vgg模型，包含上面所列的风格抽取层和内容抽取层 self.vgg = vgg_layers(style_layers + content_layers) self.style_layers = style_layers self.content_layers = content_layers self.num_style_layers = len(style_layers) # vgg各层参数锁定不再参数训练 self.vgg.trainable = False def call(self, input): # 输入的图片是0-1范围浮点，转换到0-255以符合vgg要求 input = input*255.0 # 对输入图片数据做预处理 preprocessed_input = tf.keras.applications.vgg19.preprocess_input(input) # 获取风格层和内容层输出 outputs = self.vgg(preprocessed_input) # 输出实际是一个数组，拆分为风格输出和内容输出 style_outputs, content_outputs = ( outputs[:self.num_style_layers], outputs[self.num_style_layers:]) # 计算风格矩阵 style_outputs = [gram_matrix(style_output) for style_output in style_outputs] # 转换为字典 content_dict = &#123;content_name: value for content_name, value in zip(self.content_layers, content_outputs)&#125; # 转换为字典 style_dict = &#123;style_name: value for style_name, value in zip(self.style_layers, style_outputs)&#125; # 返回内容和风格结果 return &#123;&#x27;content&#x27;: content_dict, &#x27;style&#x27;: style_dict&#125;# 使用自定义模型建立一个抽取器extractor = StyleContentModel(style_layers, content_layers)# 设定风格特征的目标，即最终生成的图片，希望风格上尽量接近风格图片style_targets = extractor(style_image)[&#x27;style&#x27;]# 设定内容特征的目标，即最终生成的图片，希望内容上尽量接近内容图片content_targets = extractor(content_image)[&#x27;content&#x27;]# 内容图片转换为张量image = tf.Variable(content_image)# 截取0-1的浮点数，超范围部分被截取def clip_0_1(image): return tf.clip_by_value(image, clip_value_min=0.0, clip_value_max=1.0)# 优化器opt = tf.optimizers.Adam(learning_rate=0.02, beta_1=0.99, epsilon=1e-1)# 预定义风格和内容在最终结果中的权重值，用于在损失函数中计算总损失值# 损失函数def style_content_loss(outputs): style_outputs = outputs[&#x27;style&#x27;] content_outputs = outputs[&#x27;content&#x27;] # 风格损失值，就是计算方差 style_loss = tf.add_n([tf.reduce_mean((style_outputs[name]-style_targets[name])**2) for name in style_outputs.keys()]) # 权重值平均到每层，计算总体风格损失值 style_loss *= style_weight/num_style_layers # 内容损失值，也是计算方差 content_loss = tf.add_n([tf.reduce_mean((content_outputs[name]-content_targets[name])**2) for name in content_outputs.keys()]) content_loss *= content_weight/num_content_layers # 总损失值 loss = style_loss+content_loss return loss###################################################def high_pass_x_y(image): x_var = image[:, :, 1:, :] - image[:, :, :-1, :] y_var = image[:, 1:, :, :] - image[:, :-1, :, :] return x_var, y_var# 计算总体变分损失def total_variation_loss(image): x_deltas, y_deltas = high_pass_x_y(image) return tf.reduce_mean(x_deltas**2)+tf.reduce_mean(y_deltas**2)@tf.function() def train_step(image): with tf.GradientTape() as tape: outputs = extractor(image) loss = style_content_loss(outputs) loss += total_variation_weight*total_variation_loss(image) grad = tape.gradient(loss, image) opt.apply_gradients([(grad, image)]) image.assign(clip_0_1(image))image = tf.Variable(content_image)for n in trange(steps): train_step(image)plt.imshow(image.read_value()[0])","categories":[{"name":"人工智能","slug":"人工智能","permalink":"https://tastynoob.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"神经网络","slug":"神经网络","permalink":"https://tastynoob.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"}]},{"title":"如何使用vscode舒适的开发嵌入式","slug":"vscodeEIDE","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.133Z","comments":true,"path":"1970/01/01/vscodeEIDE/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/vscodeEIDE/","excerpt":"想必用过keil的都会被keil糟糕的编辑体验和闪瞎眼的界面折磨过使用vscode开发环境又难配置那么这里就来安利一款十分好用，功能强大的插件–EIDE","text":"想必用过keil的都会被keil糟糕的编辑体验和闪瞎眼的界面折磨过使用vscode开发环境又难配置那么这里就来安利一款十分好用，功能强大的插件–EIDE 首先，你得要有vscode，vscode可以去微软官网下载点击这里 然后在插件搜索框内搜索”EIDE”和“C++” c++插件不需多说提供了c&#x2F;c++的自动补全，跳转，自动格式化等强大功能 重点在于EIDE插件 装好后它可能会提示你需要.net框架，安装即可，安装完成后重启一次电脑重新打开vscode即可 点击侧边栏的EIDE插件 你需要指定编译器才能实现对项目的编译如果你没有选择任何工具链，那么“设置工具链路径”的图标是一个红色叉叉点击设置工具链路径它会要求你选择如下编译器根据自己的实际情况来选择编译器路径如果你使用keil开发51那么可以选择 keil c51工具链路径 点击 “keil c51”选择你安装keilc51路径下的TOOLS.INI文件 如果你正确安装了keilc51并且vscode没有配置错的话那么“设置工具链路径”的图标就会变成和我一样的黄色感叹号 接下来创建新项目点击新建项目你可以选择项目的创建方式 内置模板项目比较少，但是常用也可以从远程仓库选择你想要的模板或者自己创建空项目，自己配置 生成好项目后就如图所示 右边是你的工作区src文件夹就是存放你的代码的区域.vscode和.eide文件夹是项目配置文件夹，不可修改 按F7即可开始编译 点击侧边栏的EIDE插件图标 即可看你项目的详细信息 你可以配置项目的编译条件和烧录器 同样可以设置51的编译优化等级 几乎和keil一模一样 但是vscode拥有更高的性能和更舒适的开发体验 另外介绍一下如何使用EIDE开发K210 首先你需要下载官方riscv编译器并在EIDE里添加你的riscv编译器路径 由于k210的riscv编译器是经过调整的，因此需要额外对EIDE插件的一些设置进行修改 打开EIDE插件设置，找到“EIDE.RISCV: Tool Prefix”选项 将编译器前缀修改为“riscv64-unknown-elf-” 这是k210 riscv编译器的前缀名称 在编译器目录下可看到，注意完整的编译器前缀还要加一横 然后在EIDE中新建项目 选择“从远程仓库拉取” 找到k210模板，选择即可 新建项目完成后如图所示 这里需要添加虚拟文件夹，将src文件里面的所有文件包含进去 否则添加新文件时，无法正常编译 至此，EIDE插件的k210开发环境配置完成用户想要添加什么文件就向src文件夹里添加 除此之外EIDE插件还支持arm，架构处理器更多功能正在开发 就我个人来说开发51,stm32，k210等主流芯片完全没有问题你可以自定义主图，自定义背景享受更好的开发环境拥有更高的开发速度和开发质量 改插件由国内大神开发，并拥有独立的论坛和qq群可供玩耍另外还有详细的插件文档点击这里","categories":[{"name":"其它","slug":"其它","permalink":"https://tastynoob.github.io/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://tastynoob.github.io/tags/vscode/"}]},{"title":"多线程操作系统原理","slug":"多线程操作系统原理","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.165Z","comments":true,"path":"1970/01/01/多线程操作系统原理/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/","excerpt":"论多线程是如何实现的基于arm内核","text":"论多线程是如何实现的基于arm内核 在裸机系统中有一个主线程和多个子线程一个线程执行一个函数每个线程都有自己独自的栈区与代码区 当使用单核cpu时为了保证每个线程都能执行因此cpu采用一种特殊的机制来切换线程即分配给每个线程一个时间片该线程的运行时间结束后，即切换栈区和代码区进行线程切换此时为串行线程这里使用汇编来实现简单的线程切换 123456789101112131415///保存当前线程///调用该函数时会将调用处的pc值保存进lr寄存器__asm void Save()&#123;push &#123;r0-r14&#125;;将当前所有寄存器保存进当前栈区，包括lr,spmov sp,stack;将sp栈寄存器写为相应线程的栈区bx func;跳转到相应线程的执行代码区&#125;//加载线程__asm void Load()&#123;mov sp,stack;将sp栈寄存器写为相应线程的栈区pop &#123;r0-r14&#125;;将下个线程栈区中保存的寄存器值还原bx lr;回到之前调用保存线程函数的地方往下执行&#125; 在实际应用当中肯定不会只有这么简单的代码实际上，要考虑到每个线程的重要性和运行时段，即线程优先级和线程睡眠 例如： 1234567891011线程1运行1ms线程1睡眠10ms 线程2运行2ms 线程2睡眠2ms 线程3运行2ms 线程3睡眠2ms 线程2运行2ms 线程2睡眠4ms 线程3运行4ms 线程3睡眠5ms线程1运行.... 如此往复 现在我已经在riscv平台上开发了一个多线程系统，具体可参考我的另一篇博客：基于riscv的真多线程系统","categories":[{"name":"其它","slug":"其它","permalink":"https://tastynoob.github.io/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"系统","slug":"系统","permalink":"https://tastynoob.github.io/tags/%E7%B3%BB%E7%BB%9F/"}]},{"title":"平衡小车制作","slug":"平衡小车制作","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.166Z","comments":true,"path":"1970/01/01/平衡小车制作/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/%E5%B9%B3%E8%A1%A1%E5%B0%8F%E8%BD%A6%E5%88%B6%E4%BD%9C/","excerpt":"emmmm,学校工作室寒假答辩作品设计","text":"emmmm,学校工作室寒假答辩作品设计 老规矩，不废话 材料: 2个编码电机 纯手工打磨(雾)木板一块 stm32f1核心板一块 ESP8266-1s一块 GY521一块 锂电池2个 稳压模块一个 驱动模块一个 算法需求: PID控制 ESP8266通信 MPU6050读取 平衡小车的原理实际上很简单无非就一个道理：你前倾我就往前加速，后倾就往后加速电机控制使用PWM控制 平衡小车需要使用到3个控制环：分别是平衡环，速度环，转向换接下来介绍PID算法此处只介绍算法的简便形式，可以在此基础上做改进 首先3个控制环负责联合控制平衡车的左右两个轮子3个控制换可得到3个值:dc_balance,dc_speed,dc_turn 左右2个电机PWM占空比dc_left&#x3D;dc_balance+dc_speed+dc_turndc_right&#x3D;dc_balance+dc_speed-dc_turn 平衡环: 1234error = angle_this-angle_balanceerror_integral+=errorgyro = getGyro(tilt)dc_balance=kp*error+ki*error_integral+kd*gyro 速度环环: 123error = (speed_left+speed_right)-speed_pointerror_integral+=errordc_speed=kp*error+ki*error_integral 转向环: 123turn = turn_pointgyro = getGyro(turn)dc_bturn=kp*turn+kd*gyro","categories":[{"name":"算法","slug":"算法","permalink":"https://tastynoob.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://tastynoob.github.io/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"用express框架自己设计web服务器","slug":"用express框架自己设计web服务器","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.166Z","comments":true,"path":"1970/01/01/用express框架自己设计web服务器/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/%E7%94%A8express%E6%A1%86%E6%9E%B6%E8%87%AA%E5%B7%B1%E8%AE%BE%E8%AE%A1web%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"使用nodejs的express框架搭建一台web服务器","text":"使用nodejs的express框架搭建一台web服务器 首先要安装express框架命令行输入 1npm install -g express 等待安装完成即可这里是全局安装express框架需要设置环境变量NODE_PATH将express模块路径添加到NODE_PATH中 另外，你需要简单了解路由的概念比如：baidu.com&#x2F;file&#x2F;2333.jpg其中 “baidu.com”是host“&#x2F;file”指的就是路由，由服务器处理你需要申请访问的路由“&#x2F;file&#x2F;2333.jpg” 需要就是访问的链接 接下来，直接上代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//导入express模块var express = require(&#x27;express&#x27;);var bodyParser = require(&#x27;body-parser&#x27;);var url = require(&#x27;url&#x27;);var app = express();// 创建 application/x-www-form-urlencoded 编码解析var urlencodedParser = bodyParser.urlencoded(&#123; extended: false &#125;)//这里是服务器处理GET请求的方法//&#x27;*&#x27;代表处理任何GET链接//比如GET baidu.com/2333/ ,&quot;/2333/&quot;就会被该get方法所接受//同时传递相关参数给回调函数app.get(&#x27;*&#x27;, function (req, res) &#123; //解析传入的路由链接，如果传入的链接包含中文，需要使用URI反编码 var reqPath = decodeURI(url.parse(req.url).pathname); //输出GET请求客户端的IP地址，以及链接 console.log(&#x27;GET请求地址：&#x27; + req.ip.match(/\\d+\\.\\d+\\.\\d+\\.\\d+/) + &quot;;链接：&quot; + reqPath); //这里做个小示范 //如果GET /file/的话，就把本地路径下/file/index.html文件发送给客户端 var filePath; if (reqPath.endsWith(&#x27;/&#x27;)) &#123; filePath = reqPath.substr(1) + &#x27;index.html&#x27;; if (fs.existsSync(filePath)) &#123; //该方法可直接发送文件，包括文本，图片等... res.sendFile(filePath); &#125; else &#123;//如果没有该文件 //该方法直接发送目标数据 res.send(&quot;访问错误！！&quot;); &#125; &#125; else &#123; filePath = __dirname + reqPath; if (fs.existsSync(filePath)) &#123; res.sendFile(filePath); &#125; else &#123; res.send(&quot;访问错误！！&quot;); &#125; &#125;&#125;)//这里是处理POST请求//&#x27;*&#x27;表示处理任何POST链接//比如 POST /ADD/,那么“/ADD/”就会被该方法所接受//同时传递相关参数给回调函数app.post(&#x27;*&#x27;, urlencodedParser, function (req, res) &#123; //解析POST链接 var reqPath = decodeURI(url.parse(req.url).pathname); console.log(&#x27;POST请求地址：&#x27; + req.ip.match(/\\d+\\.\\d+\\.\\d+\\.\\d+/) + &quot;;链接：&quot; + reqPath); //打印客户端传过来的POST数据，可以是json字符串或者其它什么的 //比如客户端POST /hello,并发送“hello world”字符串, //那么此处就会打印hello world console.log(req.body); //post请求也需要给客户端一个回应 res.send(&quot;成功！！&quot;);&#125;)//启动服务器//web服务器需要提供80端口给外部访问var server = app.listen(80, function () &#123; console.log(&quot;启动服务器&quot;); //服务器默认的IP地址就是当前主机的IP地址 console.log(server.address());&#125;) 当然可以可使用专门的GET，POST路由来处理专门的请求 1234567891011app.get(&#x27;/get&#x27;,参数省略)//这里只接受/get路由//例如 baidu.com/get/ , baidu.com/get/2333.jpg//不接受 baidu.com/233/app.post(&#x27;/post&#x27;,参数省略)//这里只接受/post路由//例如 baidu.com/post/ , baidu.com/post/2333.jpg//不接受 baidu.com/233/ 路由也可以是某个文件 12345app.get(&#x27;/233.jpg&#x27;,参数省略)//这里只接受/233.jpg路由//例如 baidu.com/233.jpg//不接受 baidu.com/233 如果想让客户端访问服务器中一个文件夹里所有的文件实现一个简单的文件服务器可以使用 “use”方法 1234app.use(&#x27;/public&#x27;, express.static(&#x27;DataBase&#x27;));//当客户端提交GET /public/233.jpg请求//那么服务器会将本地路径下 DataBase/233.jpg发送给客户端 有关express框架详细教程可参见菜鸟教程","categories":[{"name":"框架","slug":"框架","permalink":"https://tastynoob.github.io/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://tastynoob.github.io/tags/nodejs/"}]},{"title":"移植LVGL","slug":"移植LVGL","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.167Z","comments":true,"path":"1970/01/01/移植LVGL/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/%E7%A7%BB%E6%A4%8DLVGL/","excerpt":"移植LVGL的方法","text":"移植LVGL的方法 首先你要去LVGL的github上下载lvgl源代码 下载完后解压你会得到如下文件: 其中src文件夹下为LVGL源码，不可修改 examples下为LVGL与硬件交互的接口模板 lv_conf_template.h为LVGL设置模板 lvgl.h为LVGL库调用头文件 LVGL的移植十分简单 仅仅只需要提供刷屏函数就能完成lvgl基本的显示功能 首先把需要的文件全部移到项目里，需要复制一下文件： 123src文件夹examples/porting文件夹lvgl.h和lv_conf_template.h文件 接下来是进行基本的配置 首先把lv_conf_template.h文件改名为lv_conf.h 再将lvgl_conf.h宏开启 把0改成1就行了 然后是更改lv_conf.h里面的设置找到： 123456789101112131415161718192021//设置屏幕的像素宽#define LV_HOR_RES_MAX (480)//设置屏幕的像素高#define LV_VER_RES_MAX (320)//设置颜色位宽，默认16位颜色#define LV_COLOR_DEPTH 16//设置显存大小#define LV_DISP_ROT_MAX_BUF (10U * 1024U)//设置像素密度，一般设置为60#define LV_DPI 130 //设置是否使用GPU，如果没有就设为0关了#define LV_USE_GPU 1 //设置是否使用文件系统#define LV_USE_FILESYSTEM 1 目前就这些主要设置，根据自己的实际情况来看 设置无误后先进行一次编译，如果lvgl设置正确，那么编译应该会通过 接下来就是编写lvgl与硬件交互的底层驱动 打开poting文件夹 把lv_port_disp_template.c改名为lv_port_disp.c 把lv_port_disp_template.h改为lv_port_disp.h 记住修改lv_port_disp.c时同样要修改头文件名 开启这几个文件的宏 修改lv_port_disp.h文件内容如下： 在lv_port_disp.c中找到lv_port_disp_init函数 12345678910111213141516171819/* Example for 1) */static lv_disp_buf_t draw_buf_dsc_1;static lv_color_t draw_buf_1[LV_HOR_RES_MAX * 10]; /*A buffer for 10 rows*/lv_disp_buf_init(&amp;draw_buf_dsc_1, draw_buf_1, NULL, LV_HOR_RES_MAX * 10); /*Initialize the display buffer*//* Example for 2) */static lv_disp_buf_t draw_buf_dsc_2;static lv_color_t draw_buf_2_1[LV_HOR_RES_MAX * 10]; /*A buffer for 10 rows*/static lv_color_t draw_buf_2_2[LV_HOR_RES_MAX * 10]; /*An other buffer for 10 rows*/lv_disp_buf_init(&amp;draw_buf_dsc_2, draw_buf_2_1, draw_buf_2_2, LV_HOR_RES_MAX * 10); /*Initialize the display buffer*//* Example for 3) */static lv_disp_buf_t draw_buf_dsc_3;static lv_color_t draw_buf_3_1[LV_HOR_RES_MAX * LV_VER_RES_MAX]; /*A screen sized buffer*/static lv_color_t draw_buf_3_2[LV_HOR_RES_MAX * LV_VER_RES_MAX]; /*An other screen sized buffer*/lv_disp_buf_init(&amp;draw_buf_dsc_3, draw_buf_3_1, draw_buf_3_2, LV_HOR_RES_MAX * LV_VER_RES_MAX); /*Initialize the display 找到这一段代码 这3个例子是驱动屏幕的方式，选择第一种即可，把其它2种注释掉 在上面的代码下找到这2行 123456//显示范围宽度disp_drv.hor_res = 480;//显示范围高度disp_drv.ver_res = 320; 在下面找到disp_flush函数，这个函数就是核心的显示屏刷屏函数 12345678910111213141516171819202122232425262728//参数说明：//disp_drv:不用管//area:显示范围的x1，y1,x2,y2,坐标//color_p:像素点，可视为16位整数static void disp_flush(lv_disp_drv_t * disp_drv, const lv_area_t * area, lv_color_t * color_p)&#123; /*The most simple case (but also the slowest) to put all pixels to the screen one-by-one*/ int32_t x; int32_t y; for(y = area-&gt;y1; y &lt;= area-&gt;y2; y++) &#123; for(x = area-&gt;x1; x &lt;= area-&gt;x2; x++) &#123; //这里编写你的绘制一个像素点的函数，但实际上这种效率很低 /* put_px(x, y, *color_p)*/ color_p++; &#125; &#125; //如果有类似于这种函数的话，建议用这种，速度更快 //lcd_draw(area-&gt;x1,area-&gt;y1,area-&gt;x2,area-&gt;y2,(uint16_t*)color_p); /* IMPORTANT!!! * Inform the graphics library that you are ready with the flushing*/ lv_disp_flush_ready(disp_drv);&#125; 至此，lvgl与显示屏的接口编写完成 接下来做个简单的测试 123456789101112131415161718192021222324252627#inclue &quot;lvgl.h&quot;int main()&#123; lv_init(); lv_port_disp_init(); lv_port_indev_init(); //创建一个图形按钮 lv_obj_t* btn = lv_btn_create(lv_scr_act(), NULL); //设置按钮大小 lv_obj_set_pos(btn, 10, 10); //设置按钮位置 lv_obj_set_size(btn, 120, 50); //开启lvgl工作线程，这个函数主要处理lvgl图像绘制和事件响应等任务 task_run(lv_task_handler); while(1)&#123; //心跳函数，设置为1代表循环一次消耗1ms，用来设置lvgl的事件频率 //比如lvgl动画，如果在1ms内运行100次lv_tick_inc(1) //那么动画速度理论上会快100倍 lv_tick_inc(1); delayms(1); &#125;&#125; 如果lvgl能正常工作，那么屏幕上应该会绘制一个按钮 接下来是移植输入设备 与上面一样 在porting下找到lv_port_indev_template.c和lv_port_indev_template.h 然后修改文件名，宏 修改lv_port_indev.h文件内容如下 再修改修改lv_port_indev.c里面的代码 lv_port_indev.c里面提供的接口比较多，这里只介绍编写触摸按键接口 找到一下代码 12345678910111213141516171819202122232425/*------------------ * Button * -----------------*//*Initialize your button if you have*/button_init();/*Register a button input device*/lv_indev_drv_init(&amp;indev_drv);indev_drv.type = LV_INDEV_TYPE_BUTTON;indev_drv.read_cb = button_read;indev_button = lv_indev_drv_register(&amp;indev_drv);/*Assign buttons to points on the screen*///这里是按钮映射//比如按下ID为0的按钮就相当于点击屏幕（10，10）的位置static const lv_point_t btn_points[2] = &#123; &#123;10, 10&#125;, /*Button 0 -&gt; x:10; y:10*/ &#123;40, 100&#125;, /*Button 1 -&gt; x:40; y:100*/&#125;;//这里默认使用button接口lv_indev_set_button_points(indev_button, btn_points); 代码中默认使用button接口，我们只需要把按键映射改一下就行 然后找到按钮的接口 1234567891011121314151617181920212223242526272829303132/*Get ID (0, 1, 2 ..) of the pressed button*///获取按键按下的IDstatic int8_t button_get_pressed_id(void)&#123; uint8_t i; /*Check to buttons see which is being pressed (assume there are 2 buttons)*/ for(i = 0; i &lt; 2; i++) &#123; /*Return the pressed button&#x27;s ID*/ if(button_is_pressed(i)) &#123; return i; &#125; &#125; /*No button pressed*/ return -1;&#125;/*Test if `id` button is pressed or not*///确认按键是否被按下static bool button_is_pressed(uint8_t id)&#123; /*Your code comes here*/ return false;&#125; 这里就按自己的意愿改了 同样再做一个小测试 #inclue &quot;lvgl.h&quot; int main()&#123; lv_init(); lv_port_disp_init(); lv_port_indev_init(); //创建一个图形按钮 lv_obj_t* btn = lv_btn_create(lv_scr_act(), NULL); //设置按钮大小 lv_obj_set_pos(btn, 10, 10); //设置按钮位置 lv_obj_set_size(btn, 120, 50); //这里是设置lvgl按钮的事件 lv_obj_set_event_cb(btn, [](lv_obj_t* btn, lv_event_t event) &#123; switch (event) &#123; //第一次按下 case LV_EVENT_PRESSED: printf(&quot;pressed!\\n&quot;); break; //持续按下 case LV_EVENT_PRESSING: printf(&quot;pressing!\\n&quot;); break; //按钮释放 case LV_EVENT_CLICKED: printf(&quot;clicked!\\n&quot;); break; &#125; &#125;); /*Assign a call //开启lvgl工作线程，这个函数主要处理lvgl图像绘制和事件响应等任务 task_run(lv_task_handler); while(1)&#123; //心跳函数，设置为1代表循环一次消耗1ms，用来设置lvgl的事件频率 //比如lvgl动画，如果在1ms内运行100次lv_tick_inc(1) //那么动画速度理论上会快100倍 lv_tick_inc(1); delayms(1); &#125; &#125; lvgl同样可以移植文件系统，就跟上面教程一样，这里不加赘述","categories":[{"name":"框架","slug":"框架","permalink":"https://tastynoob.github.io/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"LVGL","slug":"LVGL","permalink":"https://tastynoob.github.io/tags/LVGL/"}]},{"title":"零基础神经网络科普","slug":"零基础神经网络科普","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.175Z","comments":true,"path":"1970/01/01/零基础神经网络科普/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/%E9%9B%B6%E5%9F%BA%E7%A1%80%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%A7%91%E6%99%AE/","excerpt":"简单的讲解一下人工神经网络的结构","text":"简单的讲解一下人工神经网络的结构 首先 讲一下什么是人工神经网络顾名思义，人工神经网络就是人为的模拟大脑的结构从而让人工神经网络能够完成部分智能操作 人工神经网络正如模拟大脑的一样它也由许多人工神经元组成 现实当中人脑的神经元会根据输入信号来输出相应的信号由于人脑神经元的具体活动实在是太过复杂因此人工神经元实际上会大大简化最终，它的数学模型如下它有多个输入，一个输出每个输入都占有不同的权重人工神经元内部会进行非线性运算，保证人工神经网络是非线性的 此时，这个人工神经网络的数学表达式可以写为： O &#x3D; f(ΣYᵢWᵢ) 其中f()为激活函数，通常为非线性运算函数例如sigmod函数即对输入与对应的权重相乘的和进行非线性运算 以上就是一个神经元的基本模型大量的人工神经元呈平面组合在一起就形成了BP神经网络(平面神经网络) 可以看到，BP神经网络的输入和输出的位数取决于输入层的神经元数量，相当于2个多维向量因此，再抽象一点，BP神经网络就相当于一个输入为n维的向量，输出为m维的向量的一个函数该函数的内部构造就是一个如同上图的网络 而我们要做的，就是去控制这个函数，让它能完成类似人类大脑的工作 那么如何去控制它呢 假如有一个未知函数放在你面前，要你去猜这个函数的构造你唯一的方法就是尝试去输入一个值，看这个函数的计算结果是什么比如给你一个函数 g(x) ，再给你1个输入数据 g(0) &#x3D; 0此时你还猜不到这个函数是什么,再来一个数据 g(PI&#x2F;6) &#x3D; 1&#x2F;2这时，你可能会想到g(x)&#x3D;sin(x)，但还不确认，如果 g(PI&#x2F;4) &#x3D; √2&#x2F;2此时，你会想到，该函数很大可能是g(x)&#x3D;sin(x),但凡事都可能有例外… 如果给你无穷个数据都满足g(x)&#x3D;sin(x)，那么你可以确定该函数百分百就是g(x)&#x3D;sin(x) 这里把输入未知函数的数据和该函数输出相应的值联合起来称为”输入输出数据对” 实际上，神经网络就是这样的一个“猜谜”模型 之前说了,BP神经网络就是一个抽象的向量函数我们要做的，就是不停的给它喂数据，让它去猜我们想要的函数然后利用这个函数去计算我们输入的其它数据 例如，给一个BP神经网络不停的喂g(x) &#x3D; sin(x)这个输入输出数据对那么这个神经网络就可能找到了输入输出的规律下次你输入一个之前输入输出数据对当中没有出现的数据时，它就可能明白你的意思，输出对应的值 看到这里，你可能一头雾水，既然我已经知道了g(x)&#x3D;sin(x),那么我还让神经网络去猜g(x)干啥呢？没错，让神经网络去猜g(x)函数时，它自己就变成了g(x)函数，这个过程被称为”拟合” 实际上，神经网络“拟合”的过程远比这复杂得多，别忘了，神经网络可以输入多个数据，输出多个数据同时可以拟合任意函数，这意味着我们可以尝试输入一个手写数字图像，给它一个期望输出，让它去猜：“输入手写数字图像，输出对应数字”这样的一个函数，这样一想，岂不妙哉？ 有了“输入手写数字图像，输出对应数字”这样的一个函数，我们就可以拿它去完成人工才能完成的事比如识别手写账单，几张账单可能对人类没啥压力，但如果几十万张呢，机器可不会休息，而这也是人工智能的核心：代替人类完成”人类才能完成的工作”… 而这，仅仅是“平面”神经网络，后面还有更加强大的“立体”神经网络","categories":[{"name":"其它","slug":"其它","permalink":"https://tastynoob.github.io/categories/%E5%85%B6%E5%AE%83/"},{"name":"人工智能","slug":"人工智能","permalink":"https://tastynoob.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"神经网络","slug":"神经网络","permalink":"https://tastynoob.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"}]},{"title":"无符号除法器的verilog实现","slug":"FPGA_/FPGA-BOOTHDIV","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.119Z","comments":true,"path":"1970/01/01/FPGA_/FPGA-BOOTHDIV/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/FPGA_/FPGA-BOOTHDIV/","excerpt":"无符号符号器的verilog实现","text":"无符号符号器的verilog实现 下面是它的多周期实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657module DIV ( input wire i_clk, input wire i_rstn, input wire[31:0] A, input wire[31:0] B, input i_en, output wire[31:0] Y, output wire[31:0] REM, output wire o_finish); reg finish; reg[2:0] flag; reg[10:0] cnt; reg[63:0] yrem; wire[31:0] _B = -B; wire[63:0] yrem_shift = &#123;yrem[62:0],1&#x27;b0&#125;; wire[63:0] temp = &#123;B,32&#x27;h0&#125;; initial begin flag&lt;=0; finish&lt;=0; cnt&lt;=0; yrem&lt;=0; end always @(posedge i_clk or negedge i_rstn) begin if(i_rstn == `rst)begin end else begin case(flag) 0:begin if(i_en)begin cnt&lt;=0; flag&lt;=1; finish&lt;=0; yrem &lt;= &#123;32&#x27;h0,A&#125;; end end 1:begin yrem &lt;= (yrem_shift[63:32] &gt;= B) ? yrem_shift - temp + 1&#x27;b1 : yrem_shift; cnt&lt;=cnt+1; if(cnt == 31)begin//这里是并行判断 flag &lt;=2; finish &lt;= 1; end end 2:begin flag&lt;=0; finish&lt;=0; end endcase end end assign Y = yrem[31:0]; assign REM = yrem[63:32]; assign o_finish = finish;endmodule","categories":[{"name":"fpga","slug":"fpga","permalink":"https://tastynoob.github.io/categories/fpga/"}],"tags":[{"name":"verilog","slug":"verilog","permalink":"https://tastynoob.github.io/tags/verilog/"}]},{"title":"FPGA学习-1：什么是FPGA","slug":"FPGA_/FPGA1","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.119Z","comments":true,"path":"1970/01/01/FPGA_/FPGA1/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/FPGA_/FPGA1/","excerpt":"FPGA介绍","text":"FPGA介绍 FPGA（Field Programmable Gate Array） 即现场可编程逻辑门阵列 我们都知道，所有的芯片都是由一个个晶体管组成 通过晶体管的不同组合来实现不同的功能 最常见的莫过于我们手机上的cpu 但是这些芯片的内部电路是固定的 只能完成特定功能 即使是cpu也是靠提前设计好的指令来完成不同任务 但是他们都有一些共同点，那就是都依赖于基本的逻辑门电路 而正如FPGA的名字一样，可编程逻辑门 意味着可以通过编程来设计逻辑门的组合关系 来实现不同的电路 可以以极低的学习成本来学习数字电路，甚至是设计CPU这类复杂电路 FPGA的内部构造也是十分简单粗暴 FPGA由许多LUT（Look-Up-Table 查找表）构成 实际上，考虑到各种因素，真正的“可编程逻辑门”很难实现 因此FPGA采用了一种巧妙的方式 使用LUT来模拟逻辑单元的真值表 当输入一个信号时，就根据这个表来输出对应的信号 来实现目标逻辑单元的功能 这就是为什么LUT叫“查找表” 总之，有了FPGA 我们就可以无需依赖特殊设备来设计电路","categories":[{"name":"fpga","slug":"fpga","permalink":"https://tastynoob.github.io/categories/fpga/"}],"tags":[{"name":"verilog","slug":"verilog","permalink":"https://tastynoob.github.io/tags/verilog/"}]},{"title":"BOOTH乘法器的verilog实现","slug":"FPGA_/FPGA-BOOTHMUL","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.119Z","comments":true,"path":"1970/01/01/FPGA_/FPGA-BOOTHMUL/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/FPGA_/FPGA-BOOTHMUL/","excerpt":"BOOTH乘法器的verilog实现","text":"BOOTH乘法器的verilog实现 booth乘法器是一种有符号整数乘法器下面是它的多周期实现至于原理就懒得讲了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//booth多周期乘法器module BOOTH_MUL ( input wire i_clk, input wire i_rstn, input wire[31:0] A, input wire[31:0] B, input i_en, output wire[63:0] Y, output wire o_finish); reg[64:0] p; reg finish; reg[15:0] cnt; reg[1:0] tag; initial begin p&lt;=0; finish&lt;=0; cnt&lt;=0; tag&lt;=0; end wire[31:0] _A = 0-A;//被乘数B的负数 wire b0 = p[0]; wire b1 = p[1]; //p的高32位 wire[31:0] ph = b0^b1 ? (p[64:33] + (b1 ? _A : A)) : p[64:33]; always @(posedge i_clk or negedge i_rstn) begin if(i_rstn == `rst)begin end else begin case(tag) 0:begin if(i_en)begin p &lt;= &#123;32&#x27;b0,B,1&#x27;b0&#125;; finish&lt;=0; cnt&lt;=0; tag&lt;=1; end end 1:begin cnt &lt;= cnt + 1; p &lt;= &#123;ph[31],ph,p[32:1]&#125;; if(cnt == 31)begin//这里是并行判断 tag &lt;=2; finish&lt;=1; end end 2:begin tag&lt;=0; finish&lt;=0; end endcase end end assign o_finish = finish; assign Y = p[64:1];endmodule","categories":[{"name":"fpga","slug":"fpga","permalink":"https://tastynoob.github.io/categories/fpga/"}],"tags":[{"name":"verilog","slug":"verilog","permalink":"https://tastynoob.github.io/tags/verilog/"}]},{"title":"FPGA-可配置的FIFO模块","slug":"FPGA_/FPGA-FIFO","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.119Z","comments":true,"path":"1970/01/01/FPGA_/FPGA-FIFO/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/FPGA_/FPGA-FIFO/","excerpt":"FPGA-可配置的FIFO模块","text":"FPGA-可配置的FIFO模块 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071module FIFO #( parameter unitwid = 1, parameter unitdpth = 2)( input wire i_clk, input wire i_rstn, input wire i_wen, input wire[unitwid-1:0] i_unitdata, output wire o_full, input wire i_ren, output reg[unitwid-1:0] o_unitdata, output wire o_empty); function integer clogb2 (input integer bit_depth); begin for(clogb2=0; bit_depth&gt;0; clogb2=clogb2+1) bit_depth = bit_depth&gt;&gt;1; end endfunction reg[unitwid-1:0] fifo_units[unitdpth-1:0]; reg[clogb2(unitdpth)-1:0] hptr,eptr,count; assign o_full = (count == unitdpth); assign o_empty = ~(|count); wire[clogb2(unitdpth)-1:0] hptr_1 = ((hptr == unitdpth) ? 0 : (hptr + 1)); wire[clogb2(unitdpth)-1:0] eptr_1 = ((eptr == unitdpth) ? 0 : (eptr + 1)); initial begin hptr&lt;=0; eptr&lt;=0; count&lt;=0; end always @(posedge i_clk) begin if(~i_rstn)begin hptr&lt;=0; eptr&lt;=0; count&lt;=0; end else begin if(i_wen &amp;&amp; i_ren)begin//如果同时发生读写 hptr&lt;=hptr_1; eptr&lt;=eptr_1; end else if(i_wen &amp; (~o_full))begin//只有写 fifo_units[hptr] &lt;= i_unitdata; count&lt;=count+1; hptr&lt;=hptr_1; end else if(i_ren &amp; (~o_empty))begin//只有读 count&lt;=count-1; eptr&lt;=eptr_1; o_unitdata &lt;=fifo_units[eptr]; end end end endmodule","categories":[{"name":"fpga","slug":"fpga","permalink":"https://tastynoob.github.io/categories/fpga/"}],"tags":[{"name":"verilog","slug":"verilog","permalink":"https://tastynoob.github.io/tags/verilog/"}]},{"title":"FPGA学习-9：时序电路之串口通讯模块","slug":"FPGA_/FPGA10","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.119Z","comments":true,"path":"1970/01/01/FPGA_/FPGA10/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/FPGA_/FPGA10/","excerpt":"时序电路之串口通讯模块","text":"时序电路之串口通讯模块 通信是时序电路的基础之一 要保证信息能够在不同模块直接准确传输 通信协议是保证信息传输的格式要求 那么下面我们就来设计个最简单的 也是最基础的串口通信模块 串口通信时序这里不做介绍 该串口模块的功能描述如下： 波特率9600 停止位1 校验位无 接收字节后将字节加一发送回去 首先是PLL模块 PLL模块给串口模块提供稳定的时钟信号 代码如下： 123456789101112131415161718192021222324252627module PLL( input[31:0] sub, input clk, input rst, output reg clk_out); reg[31:0] cnt;initial begin cnt = 32&#x27;d1; clk_out = 0;end always @(posedge clk or negedge rst) begin if (rst == 0) begin cnt = 32&#x27;d1; clk_out = 0; end else if(cnt &lt; sub) begin cnt = cnt + 1; end else if(cnt &gt;= sub) begin clk_out = ~clk_out; cnt = 32&#x27;d1; endendendmodule 然后是串口模块 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798module USART( input clk, //24Mhz input rst, input rx, output reg tx); reg[7:0] buff;reg[7:0] rx_shift;reg[7:0] tx_shift;initial begin tx = 1; buff = 0; rx_shift = 0; tx_shift = 0;end wire clk0;PLL pll(.sub (32&#x27;d1250),.clk (clk),.rst (rst),.clk_out (clk0));integer rx_i = 0;integer tx_i = 0;integer rx_flag = 0;integer tx_flag = 0;integer send_flag = 0;always @(posedge clk0 or negedge rst)begin if(rst == 0)begin rx_i=0; tx_i = 0; rx_flag=0; tx_flag = 0; tx = 1; buff = 0; rx_shift = 0; tx_shift = 0; end else begin case(rx_flag) 0:begin //起始位 if(rx==0)begin rx_flag=1; end end 1:begin//数据位 rx_shift = rx_shift + &#123;rx,7&#x27;d0&#125;; if(rx_i &lt; 7)begin rx_shift = rx_shift &gt;&gt; 1; end rx_i = rx_i + 1; if (rx_i &gt;= 8)begin rx_flag = 2; rx_i = 0; end end 2:begin//结束位 if(rx == 1)begin buff = rx_shift; rx_shift = 0; send_flag = 1; rx_flag = 0; end end endcase if( send_flag==1 )begin case(tx_flag) 0:begin tx_shift = buff + 1; tx = 0; tx_flag=1; end 1:begin tx = tx_shift[0]; tx_shift = tx_shift &gt;&gt; 1; tx_i = tx_i+1; if(tx_i &gt;= 8)begin tx_flag = 2; tx_i = 0; end end 2:begin tx = 1; tx_flag = 0; send_flag = 0; end endcase end end endendmodule 管脚映射如下： 连接USB转串口模块 使用串口调试软件进行测试： 实际使用效果如下; 可以看到，我们发送一串十六进制数据 它会自动将数据加一后再返回来 可以证明我们的代码没有问题","categories":[{"name":"fpga","slug":"fpga","permalink":"https://tastynoob.github.io/categories/fpga/"}],"tags":[{"name":"verilog","slug":"verilog","permalink":"https://tastynoob.github.io/tags/verilog/"}]},{"title":"FPGA：8051内核移植","slug":"FPGA_/FPGA11","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.119Z","comments":true,"path":"1970/01/01/FPGA_/FPGA11/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/FPGA_/FPGA11/","excerpt":"FPGA：8051内核移植","text":"FPGA：8051内核移植 代码全部都在GitHub仓库 适用于任何fpga芯片 推荐sipeed的tang perimer开发板","categories":[{"name":"fpga","slug":"fpga","permalink":"https://tastynoob.github.io/categories/fpga/"}],"tags":[{"name":"verilog","slug":"verilog","permalink":"https://tastynoob.github.io/tags/verilog/"}]},{"title":"FPGA-10：设计个简单的cpu(真的简单！)","slug":"FPGA_/FPGA12","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.120Z","comments":true,"path":"1970/01/01/FPGA_/FPGA12/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/FPGA_/FPGA12/","excerpt":"编写一个简单的cpu","text":"编写一个简单的cpu 经过了之前的学习 想必各位对verilog应该有了基本的基础 那么，接下来，我们就来造cpu吧！ 我们将写一个简单的单周期cpu 该cpu有一下特点： 32位架构 单周期执行 简洁实用 32位定长指令 有手就行 我称之为 “ant” 内核 就跟蚂蚁一样，“功能弱小”，但也什么能干 我也特地为该cpu编写了个汇编器 包括使用python编写的bin转txt工具 连接如下： click me 下载该项目 即可得到5个文件 123456789cpu.v: ant内核核心文件test.v : ant内核仿真文件ant-asm.exe: ant汇编器binTotxt.py:将bin文件转换成verilog可读取的储存器填充文件demo.ant:ant汇编例程 下面是寄存器说明及指令集： 1234567891011121314151617181920212223寄存器：r0~r8 共16个32位寄存器，均可可读可写，r0~r14 通用寄存器r15 pc寄存器指令集:(总共14条)wh r0,num 写r0寄存器的高16位 &#123;8&#123;指令&#125;,4&#123;寄存器id&#125;,16&#123;常数&#125;，4&#123;无意义&#125;&#125;wl r0,num 写r0寄存器的低16位 &#123;8&#123;指令&#125;,4&#123;寄存器id&#125;,16&#123;常数&#125;，4&#123;无意义&#125;&#125;add r0,r1,r2 : r0 = r1 + r2 //整数加法 &#123;8&#123;指令&#125;，4&#123;r0寄存器id&#125;,4&#123;r1寄存器id&#125;,4&#123;r2寄存器id&#125;,12&#123;无意义&#125;&#125;sub r0,r1,r2 : r0 = r1 - r2 //整数减法 &#123;8&#123;指令&#125;，4&#123;r0寄存器id&#125;,4&#123;r1寄存器id&#125;,4&#123;r2寄存器id&#125;,12&#123;无意义&#125;&#125;or r0,r1,r2 : r0 = r1 | r2 &#123;8&#123;指令&#125;，4&#123;r0寄存器id&#125;,4&#123;r1寄存器id&#125;,4&#123;r2寄存器id&#125;,12&#123;无意义&#125;&#125;and r0,r1,r2 : r0 = r1 &amp; r2 &#123;8&#123;指令&#125;，4&#123;r0寄存器id&#125;,4&#123;r1寄存器id&#125;,4&#123;r2寄存器id&#125;,12&#123;无意义&#125;&#125;not r0,r1 : r0 = ~r1 &#123;8&#123;指令&#125;，4&#123;r0寄存器id&#125;,4&#123;r1寄存器id&#125;,16&#123;无意义&#125;&#125;sl r0,r1,r2 r0 = r1 &lt;&lt; r2 &#123;8&#123;指令&#125;，4&#123;r0寄存器id&#125;,4&#123;r1寄存器id&#125;,4&#123;r2寄存器id&#125;,12&#123;无意义&#125;&#125;sr r0,r1,r2 : r0 = r1 &gt;&gt; r2 &#123;8&#123;指令&#125;，4&#123;r0寄存器id&#125;,4&#123;r1寄存器id&#125;,4&#123;r2寄存器id&#125;,12&#123;无意义&#125;&#125;mt r0,r1,r2 : r0 = r1 &gt; r2 //比大小 返回0或1 &#123;8&#123;指令&#125;，4&#123;r0寄存器id&#125;,4&#123;r1寄存器id&#125;,16&#123;无意义&#125;&#125;lt r0,r1,r2 : r0 = r1 &lt; r2//同上 &#123;8&#123;指令&#125;，4&#123;r0寄存器id&#125;,4&#123;r1寄存器id&#125;,16&#123;无意义&#125;&#125;rd r0,r1 : r1 = *r0//读内存 &#123;8&#123;指令&#125;，4&#123;r0寄存器id&#125;,4&#123;r1寄存器id&#125;,16&#123;无意义&#125;&#125;wd r0,r1 : *r0 = r1//写内存 &#123;8&#123;指令&#125;，4&#123;r0寄存器id&#125;,4&#123;r1寄存器id&#125;,16&#123;无意义&#125;&#125;if r0 :如果r0为非0，则跳过下一条指令 虽然指令只有短短14条，但也几乎能够完成所有事了 接下来我们来写个简单的1+2+3+…+100的程序 c代码如下： 123456789101112131415161718int main() &#123; int all = 0; int i = 1; int j = 101; int k = 0;l1: k = i &lt; j; if (!k) goto l2; else all = all + i; i = i + 1; goto l1;l2: printf(&quot;%d&quot;, all);&#125; c代码对应的汇编代码汇编代码如下： 123456789101112131415161718192021222324252627282930313233//0起始地址wl r0,0 //恒为0wh r0,0wl r1,1 //恒为1wh r1,0//累加wl r2,0wh r2,0//iwl r3,1 wh r3,0//101wl r4,101 wh r4,0//kwl r5,0wh r5,0//地址16wl r6,16wh r6,0//地址22wl r7,22wh r7,0//地址16：lt r5,r3,r4if r5//如果r3小于r4add r15,r7,r0add r2, r2, r3add r3,r3,r1add r15,r6,r0//地址22：wd r0,r2 将该汇编代码保存进”demo.ant”文件中 输入命令： 12ant-asm demo.ant 即可得到 out.bin可执行文件 再执行binTotxt.py脚本（注意更改里面的路径） 得到out.list填充文件 仿真test.v文件，将out.list内容填充进rom 运行 仿真效果如下： 可以看到，正确的算出了5050这个值 说明代码和ant内核是没有什么问题的","categories":[{"name":"fpga","slug":"fpga","permalink":"https://tastynoob.github.io/categories/fpga/"}],"tags":[{"name":"verilog","slug":"verilog","permalink":"https://tastynoob.github.io/tags/verilog/"}]},{"title":"FPGA学习-2：开发板及Verilog介绍","slug":"FPGA_/FPGA2","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.120Z","comments":true,"path":"1970/01/01/FPGA_/FPGA2/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/FPGA_/FPGA2/","excerpt":"开发板及verilog介绍","text":"开发板及verilog介绍 我们将使用sipeed公司设计的tang permier开发板进行开发学习 这款开发板使用了国产EG4S20芯片 拥有2万多个逻辑门单元 价格仅100多，极具性价比 可以在上面跑riscv开源架构cpu核心 完全够用 IDE我们使用官方的安路TD软件 详细安装过程可去sipeed文档上查看 与开发程序类似 开发FPGA同样有编程语言 比如verilog，VHDL 这里使用verilog作为核心开发语言 如果你对C语言有一定的了解，有助于Verilog的快速上手。 下面是一个简单的计数器 12345678910111213141516module top( input clk, output reg[15:0] out_cnt);initial begin out_cnt = 16&#x27;b0;endalways@(clk) begin if (out_cnt == 16&#x27;d250)begin out_cnt =0; end else begin out_cnt = out_cnt + 16&#x27;b1; endendendmodule verilog语言主要以模块为单位来描述一个电路结构 描述电路的方式有行为级描述，数据流描述，结构化描述 越往后难度越高，更接近于原始电路设计，但逻辑控制越简单 verilog将复杂的电路功能抽象为一个个模块(module) 通过组合个各个模块来完成不同的电路 并且verilog采用自顶向下的方式进行程序设计 一步步完成各个模块再进行组合即完成一个基本的FPGA项目","categories":[{"name":"fpga","slug":"fpga","permalink":"https://tastynoob.github.io/categories/fpga/"}],"tags":[{"name":"verilog","slug":"verilog","permalink":"https://tastynoob.github.io/tags/verilog/"}]},{"title":"FPGA学习-3：环境搭建","slug":"FPGA_/FPGA3","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.120Z","comments":true,"path":"1970/01/01/FPGA_/FPGA3/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/FPGA_/FPGA3/","excerpt":"环境配置","text":"环境配置 环境配置： 安路FPGA的环境比较好搭建 直接去sipeed下载站中即可下载 如果出现没有license的情况 参加这篇帖子 新建工程： 这是安路TD开发软件的界面 新建项目点击左上角菜单的 “project” 再点击 “New Project” 选择好芯片后，就可点击“OK”建立工程了 接下来右键Hierarchy，选择“新建文件 new source” 文件类型选择verilog 文件名称可以随意 文件保存地址默认在项目文件夹下 同时要勾选 “add to project” 这样才能添加到工程参与编译 正确操作后新建的文件应该就会被添加到项目 并且成为 “top module” 这个非常重要,verilog采用自顶向下的设计模式，每个项目都有一个 “top module” verilog编译时是以“top module”开始的 比如 当你再添加一个文件时 就会发现PLL文件和start文件的图标不同 此时，start为“top module”顶层模块 而PLL作为下级模块 当然，可以右键一个模块选择 “set as top” 就可以把选中的模块作为顶层模块，而原来的顶层模块就会变为下级模块 一个项目当中 有且仅有 一个 “top module” 安路TD软件的环境配置就此结束","categories":[{"name":"fpga","slug":"fpga","permalink":"https://tastynoob.github.io/categories/fpga/"}],"tags":[{"name":"verilog","slug":"verilog","permalink":"https://tastynoob.github.io/tags/verilog/"}]},{"title":"FPGA学习-4：初步入门点个灯","slug":"FPGA_/FPGA4","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.120Z","comments":true,"path":"1970/01/01/FPGA_/FPGA4/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/FPGA_/FPGA4/","excerpt":"点灯","text":"点灯 环境配置好后就正式进入verilog的学习了 先从最简单的点灯开始 我会向你们介绍最基础的数据类型和语法规则 仍然是从我们熟悉的界面开始 转到顶层模块 start中 首先，verilog都是以模块为单位进行编程 模块以 “module” “endmodule” 作为界限 如图既是定义一个模块start,即顶层模块 当然，可以定义其它模块再设置为顶层模块 首先，一个电路模块肯定有输入输出 还有寄存器，逻辑控制什么的 先附上点灯代码 1234567891011121314151617181920module start( input button,//按键输入 output[2:0] led//3个led输出 );reg[2:0] dat=3&#x27;b111; //3个led的状态寄存器assign led = dat;//将寄存器的3个值连接到led输出//当检测到按键下降沿时触发always@(negedge button) begin //下面与c语言类似 //但也有很大的区别 if(dat == 3&#x27;b000)begin dat = 3&#x27;b111; end else begin dat = dat - 3&#x27;b1; endend//结束endmodule 这里看不懂没关系 后面再慢慢解释 先将这些代码写入顶层模块 然后保存一遍， 注意：一定要保存！！ 既然有了代码，那么该如何点灯呢？ 既不像51直接“led&#x3D;1” 也不直接操作寄存器 这里FPGA采用了一种管脚映射的方式 打开TD软件的“Tools”菜单,点击“IO Constraint” 即可看到引脚设置界面 图正中的即芯片管脚图 而下面就会出现我们定义的几个输入输出通道 分别是: button 对应K16引脚 led[0~2]分别对应R3，J14，P13这三个引脚 从开发板的原理图中可以看到 K16引脚对应“user”按钮 R3,J14,P13对应led_red,green,blue 利用管脚映射即可实现verilog模块对外部引脚的控制 设置好引脚后，即可关闭引脚编辑器 关闭时，它会提示你进行保存，点击确定，并保存引脚设置文件 此时，你的项目中就会多出一个 引脚设置文件：“.adc” 这样，点灯程序就完全配置完成了 接下来就是编译，烧录 点击此按钮进行编译 如果提示：没有license 参加这篇帖子 接下来就是烧录 使用micro-usb线插上tang permier 烧录要更新驱动 如果没有该设备 那么可能是这2个中的任意一个 选择最可能是tang permier的设备 右键-更新驱动程序-浏览我的电脑以查找驱动程序 选择安路TD软件安装目录下的driver里选择正确的驱动 我的电脑是win10 64位，因此选择win8_10_64驱动 点击下一步进行安装 驱动更新完成后 再打开安路TD 点击此按钮进入烧录界面 根据图示进行烧录即可完成 烧录完成后 按下板子上的user按钮，就会发现led出现变换闪烁 主要还是因为按键抖动的原因导致时序错误 这个可以不用担心芯片是否会损坏","categories":[{"name":"fpga","slug":"fpga","permalink":"https://tastynoob.github.io/categories/fpga/"}],"tags":[{"name":"verilog","slug":"verilog","permalink":"https://tastynoob.github.io/tags/verilog/"}]},{"title":"FPGA学习-5：仿真","slug":"FPGA_/FPGA5","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.120Z","comments":true,"path":"1970/01/01/FPGA_/FPGA5/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/FPGA_/FPGA5/","excerpt":"仿真","text":"仿真 在实际FPGA开发过程中 我们不可能直接将代码烧录进板子里进行测试 一是我们无法观察到其内部逻辑变换 而是万一代码中的逻辑有问题 直接进行甚至会导致芯片损坏 毕竟FPGA无法像单片机那样可以利用串口打印等调试方法 FPGA调试只能靠仿真 依然是拿之前我们写的点灯代码做测试 首先，仿真需要安装modelsim仿真工具 该软件的安装这里不做赘述 软件、环境变量都配置好后开始 首先FPGA仿真需要一个测试模块 我们先添加一个测试模块 test.v 在进行仿真时，仿真软件就会模拟运行test.v这个模块 点灯程序中，我们有3个输出和1个输入 因此在模拟时我们需要给目标模块提供一个模拟的输入 我们使用延时功能来产生一个固定频率的输入 然后就是启动仿真 选择如图菜单 再点击 “Behavioral Simulatin” 即行为级仿真 选择测试代码 它会生成modelsim的仿真命令行 打开命令行，依次输入以上前3条指令即可启动modelsim 在modelsim最下面的命令行一依次输入 add wave * run 1ms 然后鼠标指向仿真窗口，按住ctrl+滚动鼠标滚轮 就能看见仿真的波形 可以右键某个信号，比如out信号 选择properties 将radix设置为“unsigned”即可选择信号的数据类型 效果如下 这样二进制数据就能以无符号整数显示","categories":[{"name":"fpga","slug":"fpga","permalink":"https://tastynoob.github.io/categories/fpga/"}],"tags":[{"name":"verilog","slug":"verilog","permalink":"https://tastynoob.github.io/tags/verilog/"}]},{"title":"FPGA学习-6：简单的组合电路","slug":"FPGA_/FPGA6","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.120Z","comments":true,"path":"1970/01/01/FPGA_/FPGA6/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/FPGA_/FPGA6/","excerpt":"简单的组合电路","text":"简单的组合电路 数字电路可分为2大类： 组合电路和时序电路 组合电路的输出只取决于它的输入 并能够在一瞬间完成，与之前状态无关 时序电路则是在时钟控制下有条理的运行 受时钟信号和输入的控制，与之前状态有关 之前的点灯程序就是时序电路 现在我们先从组合电路开始学习 写一个简单的3-8译码器 我们已经了解数字电路的基本组成是逻辑门： 与门，或门，非门 由这3种逻辑门即可组成各种复杂的逻辑电路 组合逻辑电路一般都有个唯一确定的真值表 我们要设计的3-8译码器的真值表如下 输入 输出 000 00000001 001 00000010 010 00000100 011 00001000 100 00010000 101 00100000 110 01000010 111 10000010 行为级verilog代码如下： 123456789module start( input[2:0] in, output[7:0] out ); assign out = 8&#x27;b1 &lt;&lt; in;endmodule 仿真波形如下： 可以看到，输入输出符合我们设计的真值表 但用行为级描述是否过于简单？ 那我们来尝试一下门级建模 代码如下 1234567891011121314151617181920212223module start( input[2:0] in, output[7:0] out ); wire[2:0] nin;//非门not(nin[0],in[0]);not(nin[1],in[1]);not(nin[2],in[2]);//或非门nor(out[0],in[2],in[1],in[0]);nor(out[1],in[2],in[1],nin[0]);nor(out[2],in[2],nin[1],in[0]);nor(out[3],in[2],nin[1],nin[0]);nor(out[4],nin[2],in[1],in[0]);nor(out[5],nin[2],in[1],nin[0]);nor(out[6],nin[2],nin[1],in[0]);nor(out[7],nin[2],nin[1],nin[0]);endmodule 仿真波形如下： 可以看到 真值表与预期一样","categories":[{"name":"fpga","slug":"fpga","permalink":"https://tastynoob.github.io/categories/fpga/"}],"tags":[{"name":"verilog","slug":"verilog","permalink":"https://tastynoob.github.io/tags/verilog/"}]},{"title":"FPGA学习-7：较为复杂的组合电路 上","slug":"FPGA_/FPGA7","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.121Z","comments":true,"path":"1970/01/01/FPGA_/FPGA7/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/FPGA_/FPGA7/","excerpt":"FPGA学习-7：较为复杂的组合电路 上","text":"FPGA学习-7：较为复杂的组合电路 上 上一节我们学习了基本的3-8译码器组合电路verilog写法 这一次我们来点有难度的，写一个整型全加器 在此基础上再写一个单周期无符号整型乘法器 首先从简单的开始：半加器 半加器真值表 A B C 0 0 0 0 1 1 1 0 1 1 1 0 真值表可以写为： C &#x3D; A xor B 可以看到半加器就是2个1位二进制数相加 verilog行为级代码如下： 123456789module Half_adder( input A, input B, output Y);assign Y = A + B;endmodule 门级代码如下： 123456789module Half_adder( input A, input B, output Y);xor(Y,A,B);endmodule 但是要想实现8位，16位，甚至32位的整数加法单单是半加器无法完成的 实际运算过程种也有加法的进位，半加器无法传递进位信息 所以我们需要 “全加器” 全加器真值表 A B C(上一位进位信号) D(当前进位信号) Y 0 0 0 0 0 0 0 1 0 1 … … … … … 0 1 1 1 0 … … … … … 1 1 1 1 1 真值表可以写为: D &#x3D; (A and B) or (A and C) or (B and C)Y &#x3D; (A xor B) xor C 行为级代码如下: 1234567891011module Adder( input A, input B, input C, output D, output Y);assign &#123;D,Y&#125; = A+B+C;endmodule 门级代码如下 123456789101112131415161718module Adder( input A, input B, input C, output D, output Y);wire t1,t2,t3,t4;xor(t1,A,B);xor(Y,t1,C);and(t2,A,B);and(t3,A,C);and(t4,B,C);or(D,t2,t3,t4);endmodule 由于篇幅原因，下一篇再介绍加法器和乘法器的写法","categories":[{"name":"fpga","slug":"fpga","permalink":"https://tastynoob.github.io/categories/fpga/"}],"tags":[{"name":"verilog","slug":"verilog","permalink":"https://tastynoob.github.io/tags/verilog/"}]},{"title":"FPGA学习-7：较为复杂的组合电路 下","slug":"FPGA_/FPGA8","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.121Z","comments":true,"path":"1970/01/01/FPGA_/FPGA8/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/FPGA_/FPGA8/","excerpt":"FPGA学习-7：较为复杂的组合电路 下","text":"FPGA学习-7：较为复杂的组合电路 下 之前我们学会了如何写一个全加器 有了全加器我们就能制造出16位加法器等众多运算器 接下来我们来写个加法器和乘法器 简单的8位加法器如下： 1234567891011121314151617181920module Adder8( input[7:0] Ai, input[7:0] Bi, input Ci, output Do, output[7:0] Yo);wire[6:0] ds;//8个全加器Adder A0(Ai[0],Bi[0],0,ds[0],Yo[0]);Adder A1(Ai[1],Bi[1],ds[0],ds[1],Yo[1]);Adder A2(Ai[2],Bi[2],ds[1],ds[2],Yo[2]);Adder A3(Ai[3],Bi[3],ds[2],ds[3],Yo[3]);Adder A4(Ai[4],Bi[4],ds[3],ds[4],Yo[4]);Adder A5(Ai[5],Bi[5],ds[4],ds[5],Yo[5]);Adder A6(Ai[6],Bi[6],ds[5],ds[6],Yo[6]);Adder A7(Ai[7],Bi[7],ds[6],Do,Yo[7]);endmodule 如果觉得这样写太麻烦 可以使用 “批量例化” 123456789101112131415161718192021module Adder8( input[7:0] Ai, input[7:0] Bi, input Ci, output Do, output[7:0] Yo);wire[6:0] ds;Adder A0(Ai[0],Bi[0],0,ds[0],Yo[0]);genvar i;generate for(i=1;i&lt;=6;i=i+1) begin Adder As(Ai[i],Bi[i],ds[i-1],ds[i],Yo[i]); endendgenerate Adder A7(Ai[7],Bi[7],ds[6],Do,Yo[7]);endmodule 乘法器准备!!!有了加法器，我们就能实现各种的数学运算 包括乘法 乘法的思想很简单：移位相加 就跟我们拿笔算的思路一样 制作8位乘法器的输出结果最大有十六位 所以我们需要16位加法器,16位加法器的代码这里不做介绍，照葫芦画瓢即可 由于我们讲的是组合电路 所以接下来我们将制作一个单周期16位乘法器 代码如下： 12345678910111213141516171819202122232425262728293031module MUL16( input[7:0] Ai, input[7:0] Bi, output[15:0] Yo );wire[15:0] a[8:0] ; assign a[0] = Bi[0] ? &#123;8&#x27;d0,Ai&#125; : 16&#x27;d0;assign a[1] = Bi[1] ? &#123;7&#x27;d0,Ai,1&#x27;d0&#125; : 16&#x27;d0;assign a[2] = Bi[2] ? &#123;6&#x27;d0,Ai,2&#x27;d0&#125; : 16&#x27;d0;assign a[3] = Bi[3] ? &#123;5&#x27;d0,Ai,3&#x27;d0&#125; : 16&#x27;d0;assign a[4] = Bi[4] ? &#123;4&#x27;d0,Ai,4&#x27;d0&#125; : 16&#x27;d0;assign a[5] = Bi[5] ? &#123;3&#x27;d0,Ai,5&#x27;d0&#125; : 16&#x27;d0;assign a[6] = Bi[6] ? &#123;2&#x27;d0,Ai,6&#x27;d0&#125; : 16&#x27;d0;assign a[7] = Bi[7] ? &#123;1&#x27;d0,Ai,7&#x27;d0&#125; : 16&#x27;d0;wire d[7:0];wire[15:0] out[6:0];Adder16 A0(a[0],16&#x27;d0,0,d[0],out[0]);Adder16 A1(a[1],out[0],d[0],d[1],out[1]);Adder16 A2(a[2],out[1],d[1],d[2],out[2]);Adder16 A3(a[3],out[2],d[2],d[3],out[3]);Adder16 A4(a[4],out[3],d[3],d[4],out[4]);Adder16 A5(a[5],out[4],d[4],d[5],out[5]);Adder16 A6(a[6],out[5],d[5],d[6],out[6]);Adder16 A7(a[7],out[6],d[6],d[7],Yo);endmodule 当然利用verilog语言的特性实际上没必要这样写 但是这样学习FPGA会更加直观的看到电路的逻辑结构","categories":[{"name":"fpga","slug":"fpga","permalink":"https://tastynoob.github.io/categories/fpga/"}],"tags":[{"name":"verilog","slug":"verilog","permalink":"https://tastynoob.github.io/tags/verilog/"}]},{"title":"FPGA进阶：手撸神经网络","slug":"FPGA_/FPGA进阶1","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.121Z","comments":true,"path":"1970/01/01/FPGA_/FPGA进阶1/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/FPGA_/FPGA%E8%BF%9B%E9%98%B61/","excerpt":"手撸神经网络","text":"手撸神经网络 进过了之前的基础学习，想必大家应该对verilog有了个比较清晰的认识 那么接下来，我们就来撸个神经网络吧！ 首先来介绍一下该神经网络的规格：使用IEEE标准的32位浮点数运算 网络大小为3*3*3 激活函数使用relu 神经网络为固定结构 使用组合电路，这意味着只要输入一个数据就能瞬间出来结果 所有的电路模块均为组合逻辑 使用到的基本资源： 浮点运算器，浮点乘法器，浮点加法器，激活函数运算器 特别注意：所有的数据类型均为单精度浮点数 首先是激活函数运算模块 12345678module Act_Func( input[31:0] Xi, output[31:0] Yo);assign Yo = Xi[31] ? 32&#x27;d0 : Xi;endmodule 浮点运算单元： 浮点运算单元比较复杂，这里不贴代码， 12FPU_ADD(a,b,y);FPU_MUL(a,b,y); 人工神经元模块： 12345678910111213141516171819202122module Neural( input[3*32-1:0] Xi, input[3*32-1:0] Ws,//权重 input[31:0] B,//偏执 output[31:0] Yo);wire[31:0] o[2:0];FPU_MUL f1(Xi[0*32+32-1:0*32],Ws[0*32+32-1:0*32],o[0]);FPU_MUL f2(Xi[1*32+32-1:1*32],Ws[1*32+32-1:1*32],o[1]);FPU_MUL f3(Xi[2*32+32-1:2*32],Ws[2*32+32-1:2*32],o[2]);wire[31:0] t[1:0],f;FPU_ADD f4(o[0],o[1],t[0]);FPU_ADD f5(o[2],t[0],t[1]);FPU_ADD f6(B,t[1],f);Act_Func act(f,Yo);endmodule 神经网络层： 12345678910111213module Layer( input[3*32-1:0] Xi, input[3*3*32-1:0] Ws, input[3*32-1:0] Bs, output[3*32-1:0] Yo); Neural n1(Xi,Ws[0*3*32+3*32-1:0*3*32],Bs[0*32+32-1:0*32],Yo[0*32+32-1:0*32]);Neural n2(Xi,Ws[1*3*32+3*32-1:1*3*32],Bs[1*32+32-1:1*32],Yo[1*32+32-1:1*32]);Neural n3(Xi,Ws[2*3*32+3*32-1:2*3*32],Bs[2*32+32-1:2*32],Yo[2*32+32-1:2*32]);endmodule 神经网络： 1234567891011121314151617181920212223242526272829303132333435//3*3*3的神经网络module NetWork( input[3*32-1:0] Xi, output[3*32-1:0] Yo );reg[3*3*3*32-1:0] ws = &#123;32&#x27;h3DCCCCCC,32&#x27;h3DCCCCCC,32&#x27;h3DCCCCCC,32&#x27;h3DCCCCCC,32&#x27;h3DCCCCCC,32&#x27;h3DCCCCCC,32&#x27;h3DCCCCCC,32&#x27;h3DCCCCCC,32&#x27;h3DCCCCCC,32&#x27;h3DCCCCCC,32&#x27;h3DCCCCCC,32&#x27;h3DCCCCCC,32&#x27;h3DCCCCCC,32&#x27;h3DCCCCCC,32&#x27;h3DCCCCCC,32&#x27;h3DCCCCCC,32&#x27;h3DCCCCCC,32&#x27;h3DCCCCCC,32&#x27;h3DCCCCCC,32&#x27;h3DCCCCCC,32&#x27;h3DCCCCCC,32&#x27;h3DCCCCCC,32&#x27;h3DCCCCCC,32&#x27;h3DCCCCCC,32&#x27;h3DCCCCCC,32&#x27;h3DCCCCCC,32&#x27;h3DCCCCCC&#125;;reg[3*3*32-1:0] bs =&#123;32&#x27;h3DCCCCCC,32&#x27;h3DCCCCCC,32&#x27;h3DCCCCCC,32&#x27;h3DCCCCCC,32&#x27;h3DCCCCCC,32&#x27;h3DCCCCCC,32&#x27;h3DCCCCCC,32&#x27;h3DCCCCCC,32&#x27;h3DCCCCCC&#125;;wire[3*32-1:0] cen[1:0];Layer l1(Xi,ws[0*3*3*32+3*3*32-1:0*3*3*32],bs[0*3*32+3*32-1:0*3*32],cen[0]);Layer l2(cen[0],ws[1*3*3*32+3*3*32-1:1*3*3*32],bs[1*3*32+3*32-1:1*3*32],cen[1]);Layer l3(cen[1],ws[2*3*3*32+3*3*32-1:2*3*3*32],bs[2*3*32+3*32-1:2*3*32],Yo);endmodule 下面是仿真结果和电脑运行结果： 嗯，输出结果完全一样 嗯，看着是不是非常nb呢，由于使用了组合电路 因此这个模块只要输入数据就能瞬间输出数据 但由于是固定的，写死了的神经网络，所以它的搭建十分麻烦 完整代码click me","categories":[{"name":"fpga","slug":"fpga","permalink":"https://tastynoob.github.io/categories/fpga/"}],"tags":[{"name":"verilog","slug":"verilog","permalink":"https://tastynoob.github.io/tags/verilog/"}]},{"title":"FPGA学习-8：简单的时序电路","slug":"FPGA_/FPGA9","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.121Z","comments":true,"path":"1970/01/01/FPGA_/FPGA9/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/FPGA_/FPGA9/","excerpt":"简单的时序电路","text":"简单的时序电路 经过上一章的了解 组合电路的最大优势就是能直接根据输入进行输出 但其也有很多的缺点：占大量的电路资源，功耗较大，电路固定… 这一次我们来讲基本的时序电路，写一个简单的时序控制电路 再在此基础上将之前的组合电路乘法器改成时序电路 首先我们要来了解下安路FPGA的时钟信号 安路FPGA的外部24Mhz晶振信号由k14号引脚提供 使用 “IO Constraint” 引脚映射工具 将veilog模块的某一输入端口映射到k14引脚上即可得到24Mhz的时钟信号 先来设计个简单的 “可变分频器” 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455module Start( input clk, input button, output[2:0] led);reg[31:0] pll,cnt;reg[2:0] out;assign led = ~out;initial begin pll = 32&#x27;d24000000; cnt = 32&#x27;d0; out = 3&#x27;b001;endalways @(posedge clk )begin if(cnt &lt;= pll) begin cnt = cnt + 32&#x27;d1; end else begin cnt = 32&#x27;d0; out = out &lt;&lt; 1; if(out == 3&#x27;d0)begin out = 3&#x27;b001; end end endinteger i=1;always @(posedge button)begin case(i) 1:begin i=2; pll=32&#x27;d12000000; end 2:begin i=3; pll=32&#x27;d6000000; end 3:begin i=1; pll=32&#x27;d24000000; end endcaseend endmodule 引脚映射如下： 正常编译再烧录进tang perimer里，led就会交错闪烁 按下user按键，闪烁的频率就会发生改变 这最简单的分频器设计 接下来我们再尝试将上一节中的组合电路单周期乘法器改造 变成时序电路多周期乘法器 额，就不要说什么多此一举了 我们的目的是学习 代码如下 1234567891011121314151617181920212223242526272829303132333435363738module Mul( input clk, //时钟信号 input rst, //复位信号 output reg flag,//是否完成信号 input[7:0] Ai, input[7:0] Bi, output reg[15:0] result); reg[15:0] bi;initial begin bi = &#123;8&#x27;d0,Bi&#125;; flag = 0; result= 0;end integer i=0;always @(posedge clk or posedge rst) begin if(rst == 1)begin bi = Bi; flag = 0; result = 0; i=0; end else if(flag == 0)begin result = result + (Ai[i] ? bi:0); bi = bi &lt;&lt; 1; i = i + 1; if(i&gt;=8)begin flag = 1; end endend endmodule 可以看到时序逻辑会比组合逻辑复杂得多 但是也正是因为时序电路的“记忆性” 让cpu这类复杂的运算电路得以实现","categories":[{"name":"fpga","slug":"fpga","permalink":"https://tastynoob.github.io/categories/fpga/"}],"tags":[{"name":"verilog","slug":"verilog","permalink":"https://tastynoob.github.io/tags/verilog/"}]},{"title":"FPGA进阶：状态机结构","slug":"FPGA_/FPGA进阶2","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.121Z","comments":true,"path":"1970/01/01/FPGA_/FPGA进阶2/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/FPGA_/FPGA%E8%BF%9B%E9%98%B62/","excerpt":"无","text":"无 在FPGA编程中 由于FPGA本身不能像c语言那样顺序执行 也没有各种方便函数可以调用 在设计FPGA顺序执行时就会有很大的困难 因此这里介绍FPGA的状态机机制 状态机结构几乎可以用于所有的数字逻辑当中 大大减小了开发难度 下面是一个基本的顺序循环状态机 可以用来模拟c语言结构中的 “while(1)” 循环 verilog代码演示： 12345678910111213141516171819202122232425262728module test ( input clk, output reg[3:0] line); integer tag = 0; always @(posedge clk) begin case(tag) 0:begin line=4&#x27;b0001; tag = 1; end 1:begin line=4&#x27;b0010; tag = 2; end 2:begin line=4&#x27;b0100; tag = 3; end 3:begin line=4&#x27;b1000; tag = 0; end endcase end endmodule 其中tag用于状态指示器 clk时钟信号作为运行节拍 在这种基本状态机基础上可以衍生出其它状态机 这里利用状态机来设计一个石头剪刀布小游戏 状态机结构如下 verilog代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384module test ( input clk, input[2:0] a, input[2:0] b, output reg a_light, output reg b_light); integer tag = 0; integer G ; always @(posedge clk) begin case(tag) 0:begin G=10; tag = 1; a_light=0; b_light=0; end 1:begin//比较 if(a&gt;b)begin tag = 2; end else if(a&lt;b) begin tag = 3; end else begin tag = 4; end end 2:begin//a赢 G = G + 1; tag = 5; end 3:begin//b赢 G = G - 1; tag = 6; end 4:begin//平 if(G&gt;10)begin G = G - 1; end else if(G&lt;10) begin G = G + 1; end tag = 9; end 5:begin if(G &gt;= 20)begin tag = 7; end else begin tag = 1; end end 6:begin if(G &lt;= 0)begin tag = 8; end else begin tag = 1; end end 7:begin//亮a灯 a_light=1; b_light=0; tag = 0; end 8:begin//亮b灯 a_light=0; b_light=1; tag = 0; end 9:begin//亮ab灯 a_light=1; b_light=1; tag = 1 ; end endcase end endmodule","categories":[{"name":"fpga","slug":"fpga","permalink":"https://tastynoob.github.io/categories/fpga/"}],"tags":[{"name":"verilog","slug":"verilog","permalink":"https://tastynoob.github.io/tags/verilog/"}]},{"title":"FPGA进阶：流水线结构","slug":"FPGA_/FPGA进阶3","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.121Z","comments":true,"path":"1970/01/01/FPGA_/FPGA进阶3/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/FPGA_/FPGA%E8%BF%9B%E9%98%B63/","excerpt":"无","text":"无 了解了状态机结构，接下来就来学习更加高级的流水线结构 状态机结构的好处是简单方便，但是综合出来的电路时序不高 也就是很难高频工作，因为在一个时钟里要进行多次判断匹配 虽然代码看上去很简单，但是综合出来的电路十分冗杂 通常用于时序要求不高简单的电路 流水线则与之相反 流水线将一个工作拆分成多个小任务 每个小任务执行起来十分简单快速 每个小任务就是一个小模块 这样有利于时序，但是会增加电路面积和复杂度 最常见的就属cpu电路，频率动辄上Ghz 下面是一个经典的5级流水线cpu运行时序 接下来我们来使用流水线结构实现一个简单的整数乘法器 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142module mul_cell #(parameter N=4, parameter M=4 )( input clk, //时钟信号 input rstn, //复位信号 input en, //使能信号 input[M+N-1:0] mult1, //被乘数 input[M-1:0] mult2, //乘数 input[M+N-1:0] mult1_acci, //上次累加结果 output reg[M+N-1:0] mult1_o, //被乘数移位后保存值 output reg[M-1:0] mult2_shift, //乘数移位后保存值 output reg[N+M-1:0] mult1_acco, //当前累加结果 output reg rdy //预备信号 ); always @(posedge clk or negedge rstn) begin if (!rstn) begin rdy &lt;= &#x27;b0 ; mult1_o &lt;= &#x27;b0 ; mult1_acco &lt;= &#x27;b0 ; mult2_shift &lt;= &#x27;b0 ; end else if (en) begin rdy &lt;= 1&#x27;b1 ; mult2_shift &lt;= mult2 &gt;&gt; 1 ; mult1_o &lt;= mult1 &lt;&lt; 1 ; if (mult2[0]) begin //乘数对应位为1则累加 mult1_acco &lt;= mult1_acci + mult1 ; end else begin mult1_acco &lt;= mult1_acci ; //乘数对应位为1则保持 end end else begin rdy &lt;= &#x27;b0 ; mult1_o &lt;= &#x27;b0 ; mult1_acco &lt;= &#x27;b0 ; mult2_shift &lt;= &#x27;b0 ; end endendmodulemodule mul_main #(parameter N=4,//乘数1位数 parameter M=4//乘数2位数 )( input clk, input rstn, input data_rdy , input[N-1:0] mult1, input[M-1:0] mult2, output res_rdy, output[N+M-1:0] res //输出 ); wire [N+M-1:0] mult1_t [M-1:0] ; wire [M-1:0] mult2_t [M-1:0] ; wire [N+M-1:0] mult1_acc_t [M-1:0] ; wire [M-1:0] rdy_t ; //第一次例化相当于初始化，不能用 generate 语句 mul_cell #( .N(N), .M(M) ) u_mult_step0( .clk (clk), .rstn (rstn), .en (data_rdy), .mult1 (&#123;&#123;(M)&#123;1&#x27;b0&#125;&#125;, mult1&#125;), .mult2 (mult2), .mult1_acci (&#123;(N+M)&#123;1&#x27;b0&#125;&#125;), //output .mult1_acco (mult1_acc_t[0]), .mult2_shift (mult2_t[0]), .mult1_o (mult1_t[0]), .rdy (rdy_t[0]) ); //多次模块例化，用 generate 语句 genvar i; generate for(i=1; i&lt;=M-1; i=i+1) begin mul_cell #( .N(N), .M(M) ) u_mult_step( .clk(clk), .rstn(rstn), .en(rdy_t[i-1]), .mult1(mult1_t[i-1]), .mult2(mult2_t[i-1]), //上一次累加结果作为下一次累加输入 .mult1_acci(mult1_acc_t[i-1]), //output .mult1_acco(mult1_acc_t[i]), .mult1_o(mult1_t[i]), //被乘数移位状态传递 .mult2_shift(mult2_t[i]), //乘数移位状态传递 .rdy(rdy_t[i]) ); end endgenerate assign res_rdy = rdy_t[M-1]; assign res = mult1_acc_t[M-1];endmodule`timescale 1ps/1psmodule test (); reg clk=0; reg[7:0] A=0; reg[7:0] B=0; always begin #1 clk = ~clk; end always @(posedge clk) begin A = A + 1; B = B + 2; end wire[15:0] C; wire rdy; mul_main #( .N(8), .M(8) ) mul( .clk(clk), .rstn(1&#x27;b1), .data_rdy(1&#x27;b1), .mult1(A), .mult2(B), .res_rdy(rdy), .res(C) );endmodule 仿真如下 可以看到，在一开始隔了几个时钟周期后 乘法结果开始以流水形式输出，效率非常高 流水线的优点不言而喻","categories":[{"name":"fpga","slug":"fpga","permalink":"https://tastynoob.github.io/categories/fpga/"}],"tags":[{"name":"verilog","slug":"verilog","permalink":"https://tastynoob.github.io/tags/verilog/"}]},{"title":"FPGA-RISCV内核入门1","slug":"RISCV/RISCV-CORE1","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.122Z","comments":true,"path":"1970/01/01/RISCV/RISCV-CORE1/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/RISCV/RISCV-CORE1/","excerpt":"从零开始设计一个riscv内核","text":"从零开始设计一个riscv内核 本章节将致力于使用verilog设计出一个简单的5级流水线rv32i内核 对于riscv不了解的可以去riscv官网 自行下载相关文档阅读 新手可以去阅读国内大牛胡振波所编写的《手把手教你设计cpu-riscv处理器》 先对riscv指令集有几个大概的了解 包括基本rv32i指令 指令编码方式、设计思想 然后要有必要的编程知识和数电基础 verilog设计知识可以去看之前的verilog教程 verilog仿真软件使用modelsim","categories":[{"name":"fpga","slug":"fpga","permalink":"https://tastynoob.github.io/categories/fpga/"}],"tags":[{"name":"riscv","slug":"riscv","permalink":"https://tastynoob.github.io/tags/riscv/"}]},{"title":"FPGA-RISCV内核入门2","slug":"RISCV/RISCV-CORE2","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.122Z","comments":true,"path":"1970/01/01/RISCV/RISCV-CORE2/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/RISCV/RISCV-CORE2/","excerpt":"FPGA-RISCV内核入门","text":"FPGA-RISCV内核入门 首先来了解下基本的rv32i指令集及其编码 根据编码方式的不同大致可以将指令分为6种编码 根据指令功能的不同大致可以分为8种 每个指令的意思都可以在riscv文档中找到 rv32i内核总共有32个通用寄存器 其中寄存器0的值恒为0 这里也对RISCV指令集、非特权、特权架构不做详细解释 我们只专注于RISCV内核的verilog设计 具体还需去阅读RISCV官方文档 接下来就是简单介绍一下该内核的设计 这里之所以采用五级流水线是因为五级流水线最具代表性和学习性 五级流水线分别是取指、译码、执行、访存、写回 当然，实际开发中可能会做出改进","categories":[{"name":"fpga","slug":"fpga","permalink":"https://tastynoob.github.io/categories/fpga/"}],"tags":[{"name":"riscv","slug":"riscv","permalink":"https://tastynoob.github.io/tags/riscv/"}]},{"title":"FPGA-RISCV内核入门3","slug":"RISCV/RITTER-CORE3","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.122Z","comments":true,"path":"1970/01/01/RISCV/RITTER-CORE3/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/RISCV/RITTER-CORE3/","excerpt":"接下来我们就开始正式的设计RISCV cpu了","text":"接下来我们就开始正式的设计RISCV cpu了 之前说了 我们所设计的rv32i内核使用五级流水线 所以我们来了解下cpu流水线的设计方法 这是一个最简单的流水线模型 中间的可以是组合电路或者时序电路 第一个时序电路在上升沿时读取上一层电路的输出 经过中间组合&#x2F;时序电路的计算后输出到第二个时序电路 在第二个上升沿来时，第二个时序电路读取中间输出，第一个时序电路读取上层输出 如此往复。 假如中间的运算要花费多个周期，还需要将流水线暂停 多个这样的单元组成就构成了基本的流水线 对于cpu内核也是一样 即将一条指令拆分成多个步骤，然后交给流水线执行 可以确保每条指令的执行时间为1个周期，同时大大提高了时序 对于五级流水线内核：取指，译码，执行，访存，写回 取指段是时序逻辑 译码段是组合逻辑 执行段可以是组合或时序逻辑 访存是时序逻辑 写回是组合逻辑 要将每一层连接起来就要靠上图基本流水线的1级时序和2级时序电路，也可以称之为连接段 下面是取指段到译码段的连接段 123456789101112131415161718192021222324252627282930313233343536373839404142434445//取指与译码模块之间的隔离模块module IF_ID ( input wire i_clk, input wire i_rst_n, //流水线暂停 input wire i_pipe_stop, //流水线冲刷 input wire i_pipe_flush, //上级输入的指令地址 input wire[31:0] i_iaddr, //ibus输出的指令数据, input wire[31:0] i_idata, //传递给下级的指令地址 output reg[31:0] o_iaddr, //输出的指令数据 output reg[31:0] o_idata); wire en = (~i_pipe_stop | i_pipe_flush); initial begin o_iaddr&lt;=0; o_idata&lt;=0; end always @(posedge i_clk or negedge i_rst_n) begin if(i_rst_n == `rst)begin o_iaddr &lt;= 32&#x27;b0; o_idata &lt;= `inst_nop; end else if(en == `en)begin o_iaddr &lt;= (i_pipe_flush == `en) ? 32&#x27;h0 : i_iaddr; o_idata &lt;= (i_pipe_flush == `en) ? `inst_nop : i_idata; end endendmodule 下一节我们将会来了解下简单的取指过程","categories":[{"name":"fpga","slug":"fpga","permalink":"https://tastynoob.github.io/categories/fpga/"}],"tags":[{"name":"riscv","slug":"riscv","permalink":"https://tastynoob.github.io/tags/riscv/"}]},{"title":"FPGA-RISCV内核入门4","slug":"RISCV/RITTER-CORE4","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.122Z","comments":true,"path":"1970/01/01/RISCV/RITTER-CORE4/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/RISCV/RITTER-CORE4/","excerpt":"接下来我们就开始设计一个简单的取指单元","text":"接下来我们就开始设计一个简单的取指单元 首先，取指就是从储存器中取出指令 根据RISCV的指令集特征 我们将指令指针（pc寄存器）设置在取指段 为了保证取指正确，我们还要加入一个简单的握手协议 第一个周期取指段发出取指信息 第二个周期储存器读取信息发出指令，同时取指段发出第二个取指信息 第三个周期取指段读取指令，同时取指段发出第3个取指信息，储存器读取第二个信息 大致时序如下，这里没有考虑取指异常等问题 默认为不会出现异常 取指段如下设计 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150//取指模块module IF ( //时钟信号 input wire i_clk, //复位信号 input wire i_rst_n,/*分割线*/ //pc写 input wire i_pc_we, input wire[31:0] i_pc_wdata, input wire i_pipe_stop,/*分割线*///下面连接ibus总线 //ibus读取地址 output wire[31:0] o_ibus_addr, //ibus读取数据 input wire[31:0] i_ibus_data, //ibus请求信号 output reg o_ibus_req, //ibus响应信号 input wire i_ibus_rsp,/*分割线*///下面是传递下一级流水线 //传递给下级流水线的ibus地址 output wire[31:0] o_iaddr, //传递给下级流水线的ibus数据 output wire[31:0] o_idata); reg[31:0] pc;//pc寄存器 initial begin pc = 32&#x27;h0; o_ibus_req = 0; end wire valid = i_ibus_rsp &amp; (~i_pipe_stop) ; always @(posedge i_clk or negedge i_rst_n) begin if(i_rst_n == `rst)begin//复位 pc &lt;= 32&#x27;h0; o_ibus_req &lt;= 0; end else if(valid)begin pc &lt;= (i_pc_we) ? i_pc_wdata : (pc+4); end else if(i_pipe_stop) begin end //发送ibus访问请求 o_ibus_req &lt;= 1; end //将pc打一拍发送给下级流水线 //gen_dff#(32)pc_dff(i_clk,i_rst_n,valid,pc,o_iaddr); assign o_iaddr = pc; assign o_ibus_addr = pc; assign o_idata = (i_ibus_rsp &amp; (~i_pc_we)) ? i_ibus_data : `inst_nop; endmodule//取指与译码模块之间的隔离模块module IF_ID ( input wire i_clk, input wire i_rst_n, /*分割线*/ //流水线暂停 input wire i_pipe_stop, //流水线冲刷 input wire i_pipe_flush, /*分割线*/ //上级输入的指令地址 input wire[31:0] i_iaddr, //ibus输出的指令数据, input wire[31:0] i_idata,/*分割线*/ //传递给下级的指令地址 output wire[31:0] o_iaddr, //输出的指令数据 output wire[31:0] o_idata); wire en = (~i_pipe_stop | i_pipe_flush); reg[31:0] iaddr,idata; initial begin iaddr&lt;=0; idata&lt;=0; end assign o_iaddr = (i_pipe_flush == `en) ? 32&#x27;h0 : iaddr; assign o_idata = (i_pipe_flush == `en) ? `inst_nop : idata; always @(posedge i_clk or negedge i_rst_n) begin if(i_rst_n == `rst)begin iaddr &lt;= 32&#x27;b0; idata &lt;= `inst_nop; end else if(en == `en)begin iaddr &lt;= i_iaddr; idata &lt;= i_idata; end endendmodule 这里为了简便起见，并没有过多修饰，但也能够使用","categories":[{"name":"fpga","slug":"fpga","permalink":"https://tastynoob.github.io/categories/fpga/"}],"tags":[{"name":"riscv","slug":"riscv","permalink":"https://tastynoob.github.io/tags/riscv/"}]},{"title":"FPGA-RISCV内核入门5","slug":"RISCV/RITTER-CORE5","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.122Z","comments":true,"path":"1970/01/01/RISCV/RITTER-CORE5/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/RISCV/RITTER-CORE5/","excerpt":"译码段设计","text":"译码段设计 译码段是纯组合逻辑 这部分比较简单 也就是将指令译码出详细信息 这里直接贴上代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375`define decinfo_wigth (17)/*译码出的具体指令内容1&#x27;是否要进行运算[0]1&#x27;alu b位是否选择立即数[1]1&#x27;alu pc是否参与计算[2]1&#x27;是否是条件分支指令[3]1&#x27;是否是强制跳转[4]1‘是否要读内存[5]1’是否要写内存[6]1’是否要读写csr寄存器[8]3’func[11:9]7‘func7[18:12]*/`define decinfo_alu 0`define decinfo_b 1`define decinfo_pc 2`define decinfo_branch 3`define decinfo_jal 4`define decinfo_rdbus 5`define decinfo_wdbus 6`define decinfo_wcsr 7`define decinfo_func3 10:8`define decinfo_func7 17:11//译码模块module ID ( input wire i_clk, input wire i_rst_n, //解码出的具体指令 output wire[`decinfo_wigth:0] o_dec_data, //csr地址 output wire[11:0] o_csr_addr, //rd寄存器写地址 output wire[4:0] o_rd_addr1, output wire[4:0] o_rd_addr2, //rs1读地址 output wire[4:0] o_rs1_addr, //rs2读地址 output wire[4:0] o_rs2_addr, //立即数 output wire[31:0] o_imm_data, //如果是opc_load指令，那么则暂停取指直到opc_load执行完毕 output wire o_opc_load,/*分割线*/ //上级传递下来的指令地址 input wire[31:0] i_iaddr, input wire[31:0] i_idata); // 取出指令中的每一个域 wire[6:0] opc = i_idata[6:0]; wire[2:0] func = i_idata[14:12]; wire[6:0] func7 = i_idata[31:25]; wire[4:0] rd = i_idata[11:7]; wire[4:0] rs1 = i_idata[19:15]; wire[4:0] rs2 = i_idata[24:20]; wire[11:0] type_i_imm_11_0 = i_idata[31:20]; wire[6:0] type_s_imm_11_5 = i_idata[31:25]; wire[4:0] type_s_imm_4_0 = i_idata[11:7]; wire[6:0] type_b_imm_12_10_5 = i_idata[31:25]; wire[4:0] type_b_imm_4_1_11 = i_idata[11:7]; wire[19:0] type_u_imm_31_12 = i_idata[31:12]; wire[19:0] type_j_imm_31_12 = i_idata[31:12];`define opc_lui 7&#x27;b0110111 // rd = imm`define opc_auipc 7&#x27;b0010111 // rd = pc + imm`define opc_jal 7&#x27;b1101111`define opc_jalr 7&#x27;b1100111`define opc_branch 7&#x27;b1100011`define opc_load 7&#x27;b0000011`define opc_store 7&#x27;b0100011`define opc_opimm 7&#x27;b0010011`define opc_op 7&#x27;b0110011`define opc_fence 7&#x27;b0001111`define opc_system 7&#x27;b1110011 // 指令opc域的取值 wire opc_lui = (opc == `opc_lui); wire opc_auipc = (opc == `opc_auipc); wire opc_jal = (opc == `opc_jal); wire opc_jalr = (opc == `opc_jalr); wire opc_branch = (opc == `opc_branch); wire opc_load = (opc == `opc_load); wire opc_store = (opc == `opc_store); wire opc_opimm = (opc == `opc_opimm); wire opc_op = (opc == `opc_op); wire opc_fence = (opc == `opc_fence); wire opc_system = (opc == `opc_system); // 指令func域的取值 wire func_000 = (func == 3&#x27;b000); wire func_001 = (func == 3&#x27;b001); wire func_010 = (func == 3&#x27;b010); wire func_011 = (func == 3&#x27;b011); wire func_100 = (func == 3&#x27;b100); wire func_101 = (func == 3&#x27;b101); wire func_110 = (func == 3&#x27;b110); wire func_111 = (func == 3&#x27;b111); // 指令func7域的取值 wire func7_0000000 = (func7 == 7&#x27;b0000000); wire func7_0100000 = (func7 == 7&#x27;b0100000); wire func7_0000001 = (func7 == 7&#x27;b0000001); // I类型指令imm域的取值 wire type_i_imm_000000000000 = (type_i_imm_11_0 == 12&#x27;b000000000000); wire type_i_imm_000000000001 = (type_i_imm_11_0 == 12&#x27;b000000000001);/*********************************************************/ // 译码出具体指令 /*j*/ wire inst_lui = opc_lui; wire inst_auipc = opc_auipc; wire inst_jal = opc_jal; wire inst_jalr = opc_jalr &amp; func_000; /*branch*/ wire inst_beq = opc_branch &amp; func_000; wire inst_bne = opc_branch &amp; func_001; wire inst_blt = opc_branch &amp; func_100; wire inst_bge = opc_branch &amp; func_101; wire inst_bltu = opc_branch &amp; func_110; wire inst_bgeu = opc_branch &amp; func_111; /*load*/ wire inst_lb = opc_load &amp; func_000; wire inst_lh = opc_load &amp; func_001; wire inst_lw = opc_load &amp; func_010; wire inst_lbu = opc_load &amp; func_100; wire inst_lhu = opc_load &amp; func_101; /*store*/ wire inst_sb = opc_store &amp; func_000; wire inst_sh = opc_store &amp; func_001; wire inst_sw = opc_store &amp; func_010; /*opimm*/ wire inst_addi = opc_opimm &amp; func_000; wire inst_slti = opc_opimm &amp; func_010; wire inst_sltiu = opc_opimm &amp; func_011; wire inst_xori = opc_opimm &amp; func_100; wire inst_ori = opc_opimm &amp; func_110; wire inst_andi = opc_opimm &amp; func_111; wire inst_slli = opc_opimm &amp; func_001 &amp; func7_0000000; wire inst_srli = opc_opimm &amp; func_101 &amp; func7_0000000; wire inst_srai = opc_opimm &amp; func_101 &amp; func7_0100000; /*op*/ wire inst_add = opc_op &amp; func_000 &amp; func7_0000000; wire inst_sub = opc_op &amp; func_000 &amp; func7_0100000; wire inst_sll = opc_op &amp; func_001 &amp; func7_0000000; wire inst_slt = opc_op &amp; func_010 &amp; func7_0000000; wire inst_sltu = opc_op &amp; func_011 &amp; func7_0000000; wire inst_xor = opc_op &amp; func_100 &amp; func7_0000000; wire inst_srl = opc_op &amp; func_101 &amp; func7_0000000; wire inst_sra = opc_op &amp; func_101 &amp; func7_0100000; wire inst_or = opc_op &amp; func_110 &amp; func7_0000000; wire inst_and = opc_op &amp; func_111 &amp; func7_0000000; /*fence*/ wire inst_fence = opc_fence &amp; func_000; wire inst_fencei = opc_fence &amp; func_001; /*system*/ wire inst_ecall = opc_system &amp; func_000 &amp; type_i_imm_000000000000; wire inst_ebreak = opc_system &amp; func_000 &amp; type_i_imm_000000000001; wire inst_csrrw = opc_system &amp; func_001; wire inst_csrrs = opc_system &amp; func_010; wire inst_csrrc = opc_system &amp; func_011; wire inst_csrrwi = opc_system &amp; func_101; wire inst_csrrsi = opc_system &amp; func_110; wire inst_csrrci = opc_system &amp; func_111; /*M拓展*/ wire inst_mul = opc_op &amp; func_000 &amp; func7_0000001; wire inst_mulh = opc_op &amp; func_001 &amp; func7_0000001; wire inst_mulhsu = opc_op &amp; func_010 &amp; func7_0000001; wire inst_mulhu = opc_op &amp; func_011 &amp; func7_0000001; wire inst_div = opc_op &amp; func_100 &amp; func7_0000001; wire inst_divu = opc_op &amp; func_101 &amp; func7_0000001; wire inst_rem = opc_op &amp; func_110 &amp; func7_0000001; wire inst_remu = opc_op &amp; func_111 &amp; func7_0000001;/*********************************************************/ // 指令中的立即数 wire[31:0] inst_u_type_imm = &#123;i_idata[31:12], 12&#x27;b0&#125;; wire[31:0] inst_j_type_imm = &#123;&#123;12&#123;i_idata[31]&#125;&#125;, i_idata[19:12], i_idata[20], i_idata[30:21], 1&#x27;b0&#125;; wire[31:0] inst_b_type_imm = &#123;&#123;20&#123;i_idata[31]&#125;&#125;, i_idata[7], i_idata[30:25], i_idata[11:8], 1&#x27;b0&#125;; wire[31:0] inst_s_type_imm = &#123;&#123;20&#123;i_idata[31]&#125;&#125;, i_idata[31:25], i_idata[11:7]&#125;; wire[31:0] i_idata_type_imm = &#123;&#123;20&#123;i_idata[31]&#125;&#125;, i_idata[31:20]&#125;; //csr zimm wire[31:0] inst_csr_type_imm = &#123;27&#x27;h0, i_idata[19:15]&#125;; wire[31:0] inst_shift_type_imm = &#123;27&#x27;h0, i_idata[24:20]&#125;; //立即数选择 assign o_imm_data = (opc_lui | opc_auipc) ? inst_u_type_imm : (opc_jal) ? inst_j_type_imm : (opc_jalr | opc_load) ? i_idata_type_imm : (opc_branch) ? inst_b_type_imm : (opc_store) ? inst_s_type_imm : (opc_opimm) ? ((inst_slli | inst_srli | inst_srai) ? inst_shift_type_imm : i_idata_type_imm) : (inst_ecall | inst_ebreak) ? i_idata_type_imm ://这里把ecall和ebreak的后12位当作立即数处理 0; //csr寄存器地址 assign o_csr_addr = opc_system ? i_idata_type_imm : 0; // 是否需要写rd寄存器 wire access_rd = opc_lui | opc_auipc | opc_jal | opc_jalr | opc_opimm | opc_op | opc_system; assign o_rd_addr1 = access_rd ? rd: 5&#x27;h0; assign o_rd_addr2 = opc_load ? rd:5&#x27;d0; // 是否需要访问rs1寄存器 wire access_rs1 = opc_jalr | opc_branch | opc_load | opc_store | opc_opimm | opc_op | inst_csrrw | inst_csrrs | inst_csrrc; assign o_rs1_addr = access_rs1 ? rs1: 5&#x27;h0; // 是否需要访问rs2寄存器 wire access_rs2 = opc_branch | opc_store | opc_op; assign o_rs2_addr = access_rs2? rs2: 5&#x27;h0; //是否需要进行数学计算 //这个标志貌似可有可无 assign o_dec_data[`decinfo_alu] = opc_lui | opc_auipc | opc_jal | opc_jalr | opc_branch | opc_load | opc_store | opc_opimm | opc_op; //alu b位是否选择立即数 assign o_dec_data[`decinfo_b] = opc_lui | opc_auipc | opc_jal | opc_jalr | opc_load | opc_store | opc_opimm; //alu pc是否参与计算,是否是jal等跳转指令 assign o_dec_data[`decinfo_pc] = opc_auipc | opc_jal ; //是否是条件分支指令 assign o_dec_data[`decinfo_branch] = opc_branch; //是否需要强制跳转 assign o_dec_data[`decinfo_jal] = opc_jal | opc_jalr; //是否需要读内存 assign o_dec_data[`decinfo_rdbus] = opc_load; //是否需要写内存 assign o_dec_data[`decinfo_wdbus] = opc_store; //是否要读写csr寄存器 assign o_dec_data[`decinfo_wcsr] = opc_system &amp; (~(inst_ecall | inst_ebreak)); assign o_dec_data[`decinfo_func3] = (opc_lui | opc_auipc | opc_jal) ? 0 : func; assign o_dec_data[`decinfo_func7] = (inst_slli | inst_srli | inst_srai | opc_op) ? func7 : 0; assign o_opc_load = opc_load; endmodulemodule ID_EX ( input wire i_clk, input wire i_rst_n, //流水线暂停 input wire i_pipe_stop, //流水线冲刷 input wire i_pipe_flush, /**/ input wire[`decinfo_wigth:0] i_dec_data, input wire[11:0] i_csr_addr, input wire[4:0] i_rd_addr1, input wire[4:0] i_rd_addr2, input wire[4:0] i_rs1_addr, input wire[4:0] i_rs2_addr, input wire[31:0] i_imm_data, input wire i_opc_load, input wire[31:0] i_iaddr, output reg[`decinfo_wigth:0] o_dec_data, output reg[11:0] o_csr_addr, output reg[4:0] o_rd_addr1, output reg[4:0] o_rd_addr2, output reg[4:0] o_rs1_addr, output reg[4:0] o_rs2_addr, output reg[31:0] o_imm_data, output reg o_opc_load, output reg[31:0] o_iaddr ); wire en = (~i_pipe_stop) | i_pipe_flush; wire[`decinfo_wigth:0] dec_data= i_pipe_flush ? 0 : i_dec_data; wire[11:0] csr_addr= i_pipe_flush ? 0 : i_csr_addr; wire[4:0] rd_addr1= i_pipe_flush ? 0 : i_rd_addr1; wire[4:0] rd_addr2= i_pipe_flush ? 0 : i_rd_addr2; wire[4:0] rs1_addr= i_pipe_flush ? 0 : i_rs1_addr; wire[4:0] rs2_addr= i_pipe_flush ? 0 : i_rs2_addr; wire[31:0] imm_data= i_pipe_flush ? 0 : i_imm_data; wire opc_load= i_pipe_flush ? 0 : i_opc_load; wire[31:0] iaddr = i_pipe_flush ? 0 : i_iaddr; initial begin o_dec_data &lt;= 0 ; o_csr_addr &lt;=0; o_rd_addr1&lt;= 0; o_rd_addr2&lt;= 0; o_rs1_addr &lt;= 0 ; o_rs2_addr &lt;= 0 ; o_imm_data &lt;= 0 ; o_opc_load &lt;= 0; o_iaddr &lt;= 0 ; end always @(posedge i_clk or negedge i_rst_n) begin if(i_rst_n == `rst)begin o_dec_data &lt;= 0 ; o_csr_addr &lt;=0; o_rd_addr1 &lt;= 0 ; o_rs1_addr &lt;= 0 ; o_rs2_addr &lt;= 0 ; o_imm_data &lt;= 0 ; o_opc_load &lt;= 0; o_iaddr &lt;= 0 ; end else if(en == `en)begin o_dec_data &lt;= dec_data; o_csr_addr &lt;= csr_addr; o_rd_addr1 &lt;= rd_addr1; o_rd_addr2 &lt;= rd_addr2; o_rs1_addr &lt;= rs1_addr; o_rs2_addr &lt;= rs2_addr; o_imm_data &lt;= imm_data; o_opc_load &lt;= opc_load; o_iaddr &lt;= iaddr; end end endmodule 这里面没有什么特殊技术 但之前也说了，制作这个riscv内核单纯是为了学习 只要求能跑，不要求性能 译码段主要译码出的就是 1、读写寄存器地址（不读不写则设置为0）2、执行段所需资源3、是否读写csr寄存器4、是否跳转5、指令类型 然后由译码段到执行段的连接段传递","categories":[{"name":"fpga","slug":"fpga","permalink":"https://tastynoob.github.io/categories/fpga/"}],"tags":[{"name":"riscv","slug":"riscv","permalink":"https://tastynoob.github.io/tags/riscv/"}]},{"title":"FPGA-RISCV内核入门6","slug":"RISCV/RITTER-CORE6","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.123Z","comments":true,"path":"1970/01/01/RISCV/RITTER-CORE6/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/RISCV/RITTER-CORE6/","excerpt":"取指段及译码段细节分析","text":"取指段及译码段细节分析 首先是储存器说明 一般为了保证时序，所有原件皆为上升沿触发 但是这里为了保证简便和稳定 在取指段中将储存器读写改为下降沿 这样在取指时，上升沿发出地址，下降沿储存器读取地址发出数据 第二个上升沿取指读取，虽然可能降低时序，但是保证了简洁于稳定 译码段中单独的把访存信息留了一个输出 这是为了解决因为访存带来的数据冲突 如果译码段检测到是访存指令 则暂停流水线3个周期 这里没有考虑读写延迟，因此直接暂停3个周期 对于跳转控制也是得益于在下降沿储存器输出指令 因此只需在上升沿检测到跳转信号则跳转，不用担心跳转错误 也不用暂停流水线 初次之外，译码段发出寄存器读写地址信号 译码段到执行段的连接段接收 寄存器读放在执行段 这里实际上可以将寄存器读数据直接放在译码段 可以节约时序，但当时并未考虑 因此就保留了下来 译码段实际上可以译码出更详细的信息 防止执行段二次译码 这里也并未考虑 毕竟是第一版作品 更多优化技巧可以多思考思考","categories":[{"name":"fpga","slug":"fpga","permalink":"https://tastynoob.github.io/categories/fpga/"}],"tags":[{"name":"riscv","slug":"riscv","permalink":"https://tastynoob.github.io/tags/riscv/"}]},{"title":"RITTER2 Cache实现","slug":"chisel/RITTER2Cache实现","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.124Z","comments":true,"path":"1970/01/01/chisel/RITTER2Cache实现/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/chisel/RITTER2Cache%E5%AE%9E%E7%8E%B0/","excerpt":"RITTER2.0内核的Cache实现。包括ICache和DCache","text":"RITTER2.0内核的Cache实现。包括ICache和DCache ICache和DCache均使用chisel3.5设计均可配置line数和way数采用伪lru替换策略 ICache为只读，DCache为可读可写目前均以通过基本的读写测试 项目地址:click meICache 位于IFU文件夹下DCache位于Cache文件夹下","categories":[{"name":"fpga","slug":"fpga","permalink":"https://tastynoob.github.io/categories/fpga/"}],"tags":[{"name":"chisel","slug":"chisel","permalink":"https://tastynoob.github.io/tags/chisel/"}]},{"title":"chisel3书写细节","slug":"chisel/chisel3书写细节","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.124Z","comments":true,"path":"1970/01/01/chisel/chisel3书写细节/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/chisel/chisel3%E4%B9%A6%E5%86%99%E7%BB%86%E8%8A%82/","excerpt":"有关chisel3的一些书写细节以及chisel生成verilog代码的一些注意事项","text":"有关chisel3的一些书写细节以及chisel生成verilog代码的一些注意事项 首先有必要说的是模块参数化可以这样写 12345678910111213141516171819202122class dataT extends Bundle &#123; val data = UInt(32.W) val valid = Bool()&#125;class Test[T&lt;:Data](eleT:T) extends Module &#123; val io = IO(new Bundle &#123; val in = Input(Vec(2, eleT)) val out = Output(Vec(2, eleT)) &#125;) val reg0 = Reg(eleT) val reg1 = Reg(eleT) reg0 := io.in(0) reg1 := io.in(1) io.out(0) := reg0 io.out(1) := reg1&#125;object Main extends App &#123; (new chisel3.stage.ChiselStage).emitVerilog(new Test(new dataT))&#125; 有助于对模块内硬件类型的参数化,比如在fifo中 然后是chisel3的赋值语句比如下面的语句 12345678910class Test extends Module&#123; val io = IO(new Bundle&#123; val in = Input(UInt(32.W)) val out = Output(UInt(32.W)) &#125;) val reg = Reg(UInt(32.W)) reg:= io.in io.out := reg io.out := io.in&#125; 当对线网类型进行多次赋值时,由于scala本质上是顺序执行的编程语言所以后面的语句对线网类型的连接会将前面的赋值的连接覆盖掉最后生成的verilog代码如下 12345678module Test( input clock, input reset, input [31:0] io_in, output [31:0] io_out); assign io_out = io_in; // @[Main.scala 14:12]endmodule 但是当对寄存器类型做多次赋值时1234567891011class Test extends Module&#123; val io = IO(new Bundle&#123; val in0 = Input(UInt(32.W)) val in1 = Input(UInt(32.W)) val out = Output(UInt(32.W)) &#125;) val reg = Reg(UInt(32.W)) reg := io.in0 reg := io.in1 io.out := reg&#125; 生成的verilog代码 12345678910111213module Test( input clock, input reset, input [31:0] io_in0, input [31:0] io_in1, output [31:0] io_out); reg [31:0] reg_; // @[Main.scala 12:18] assign io_out = reg_; // @[Main.scala 15:12] always @(posedge clock) begin reg_ &lt;= io_in1; // @[Main.scala 14:9] endendmodule 初步生成的结果和对线网类型的多次赋值的结果是一样的 但是当我们加上条件判断12345678910111213141516class Test extends Module&#123; val io = IO(new Bundle&#123; val in0 = Input(UInt(32.W)) val in1 = Input(UInt(32.W)) val en0 = Input(Bool()) val en1 = Input(Bool()) val out = Output(UInt(32.W)) &#125;) val reg = Reg(UInt(32.W)) when(io.en0)&#123; reg := io.in0 &#125; reg := io.in1 io.out := reg&#125; 生成的verilog代码 123456789101112131415module Test( input clock, input reset, input [31:0] io_in0, input [31:0] io_in1, input io_en0, input io_en1, output [31:0] io_out); reg [31:0] reg_; // @[Main.scala 14:18] assign io_out = reg_; // @[Main.scala 20:12] always @(posedge clock) begin reg_ &lt;= io_in1; // @[Main.scala 19:9] endendmodule 很明显，这不是我们想要的verilog逻辑假如我们调换一下赋值顺序呢 1234567891011121314151617class Test extends Module&#123; val io = IO(new Bundle&#123; val in0 = Input(UInt(32.W)) val in1 = Input(UInt(32.W)) val en0 = Input(Bool()) val en1 = Input(Bool()) val out = Output(UInt(32.W)) &#125;) val reg = Reg(UInt(32.W)) reg := io.in1 when(io.en0)&#123; reg := io.in0 &#125; io.out := reg&#125; 12345678910111213141516171819module Test( input clock, input reset, input [31:0] io_in0, input [31:0] io_in1, input io_en0, input io_en1, output [31:0] io_out); reg [31:0] reg_; // @[Main.scala 14:18] assign io_out = reg_; // @[Main.scala 21:12] always @(posedge clock) begin if (io_en0) begin // @[Main.scala 17:17] reg_ &lt;= io_in0; // @[Main.scala 18:13] end else begin reg_ &lt;= io_in1; // @[Main.scala 16:9] end endendmodule 发现逻辑又对了 这是因为chisel对寄存器进行连接时,会按照从上往下的顺序进行连接后连接的拥有最大的优先级假如chisel中出现了对寄存器的多次连接生成的verilog代码中会按照chisel从后往前的优先级进行连接因此在写chisel代码时需要对同一寄存器进行多次赋值连接又不想写太多when语句就可以用这个方法来解决这个问题 最后就是chisel代码仿真问题这里使用最新的chiseltest 典型的测试代码如下 123456789101112131415161718192021class Test extends Module&#123; val io = IO(new Bundle&#123; val in = Input(UInt(32.W)) val out = Output(UInt(32.W)) &#125;) val reg = Wire(UInt(32.W)) reg := io.in io.out := reg&#125;class Test_Test extends AnyFlatSpec with ChiselScalatestTester &#123; behavior of &quot;Module&quot; it should &quot;work&quot; in &#123; //添加如下语句可以生成仿真波形图到本地,可以用gtkwave打开 test(new Test).withAnnotations(Seq(WriteVcdAnnotation)) &#123; dut =&gt; dut.io.in.poke(12.U) dut.clock.step(1) dut.io.out.expect(12.U) &#125; &#125;&#125; 注意一下,使用chiseltest无法读取内部寄存器或线网的值,只能读取io接口的值因此推荐添加如上代码生成波形图方便测试","categories":[{"name":"fpga","slug":"fpga","permalink":"https://tastynoob.github.io/categories/fpga/"}],"tags":[{"name":"chisel","slug":"chisel","permalink":"https://tastynoob.github.io/tags/chisel/"}]},{"title":"chisel3入门-环境配置","slug":"chisel/chisel3入门","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.124Z","comments":true,"path":"1970/01/01/chisel/chisel3入门/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/chisel/chisel3%E5%85%A5%E9%97%A8/","excerpt":"chisel3环境配置","text":"chisel3环境配置 介绍chisel3是一种基于scala编程语言的库,它提供了一个简单的编程接口,可以用来生成verilog代码,以及仿真和调试在学习chisel3之前，我们先来学会安装环境 环境配置chisel3是基于scala编程语言，所以你需要安装scala sdk 同时scala又是基于java虚拟机，因此你也需要安装jdk与jre jdk或jre的安装不做介绍 scala官网下载地址:https://www.scala-lang.org/download/all.html 我们选择稳定版下载:scala-2.12.15 linux和windows安装软件方法也不做介绍 windows上需要配置环境变量，将scala&#x2F;bin文件目录添加到PATH中 linux或windows下在终端输入 1scala -version 如果能正确输出scala版本号就说明你安装成功了 接下来我们还需要安装scala项目构建工具sbt 前往sbt官网下载地址:https://www.scala-sbt.org/download.html 按照官方教程即可安装完毕 终端输入 1sbt -version (第一次运行sbt可能需要下载一些资源，这个时候可以耐心等待)如果能正确显示sbt版本号则说明安装无误 接下来我们还需要安装scala开发软件 虽然可以使用vscode开发，但是vscode的scala插件支持并不友好因此还是推荐idea开发idea需要安装scala插件才能支持scala 新建项目如果前面配置都没问题就可以在新建项目里看到scala项目模板构建系统选择sbt选择好sbt和scala姐创建项目 开始chisel3开发创建完成项目后主目录应该会有一个”build.sbt”文件文件内容如下 12345678ThisBuild / version := &quot;0.1.0-SNAPSHOT&quot;//不用管ThisBuild / scalaVersion := &quot;2.13.8&quot;//scala版本lazy val root = (project in file(&quot;.&quot;)) .settings( name := &quot;untitled2&quot; ) 就跟java的maven类似我们也需要手动添加依赖包 添加chisel3依赖如下 123456789101112ThisBuild / version := &quot;0.1.0-SNAPSHOT&quot;ThisBuild / scalaVersion := &quot;2.13.8&quot;val chiselVersion = &quot;3.5.2&quot;lazy val root = (project in file(&quot;.&quot;)) .settings( name := &quot;untitled2&quot;, libraryDependencies += &quot;edu.berkeley.cs&quot; %% &quot;chisel3&quot; % chiselVersion, libraryDependencies += &quot;edu.berkeley.cs&quot; %% &quot;chiseltest&quot; % &quot;0.5.2&quot;, addCompilerPlugin(&quot;edu.berkeley.cs&quot; % &quot;chisel3-plugin&quot; % chiselVersion cross CrossVersion.full) ) 此时右上角会出现一个刷新按钮 点击右上角，重新导入依赖包,等待chisel3下载完毕 开始编写chisel代码如果chisel3包导入无误，那么我们就可以开始编写chisel代码了 打开src&#x2F;main&#x2F;scala&#x2F;Main.scala文件，添加如下代码 1234567891011121314151617import chisel3._import chisel3.stage.ChiselStageimport chisel3.util._class Test extends Module &#123; val io = IO(new Bundle &#123; val in = Input(UInt(8.W)) val out = Output(UInt(8.W)) &#125;) io.out := io.in&#125;object Main extends App &#123; (new ChiselStage).emitVerilog(new Test,Array[String](&quot;--target-dir&quot;,&quot;Generated&quot;))&#125; 点击object Main 左边的运行按钮即可运行chisel3代码 运行完成就可以在Generated文件夹下看到生成的Test.v文件了 那么环境配置就到此结束","categories":[{"name":"fpga","slug":"fpga","permalink":"https://tastynoob.github.io/categories/fpga/"}],"tags":[{"name":"chisel","slug":"chisel","permalink":"https://tastynoob.github.io/tags/chisel/"}]},{"title":"NNQ框架","slug":"框架/NNQ","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.166Z","comments":true,"path":"1970/01/01/框架/NNQ/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/%E6%A1%86%E6%9E%B6/NNQ/","excerpt":"NNQ是一个用C++设计的算法框架包含矩阵,向量,甚至包括神经网络搭建只需较少的资源即可完成大部分算法推荐用于嵌入式领域","text":"NNQ是一个用C++设计的算法框架包含矩阵,向量,甚至包括神经网络搭建只需较少的资源即可完成大部分算法推荐用于嵌入式领域 NNQ框架使用类似于神经网络层级建模的方式来构造神经网络模型目前只支持DNN网络的构建部分地方仍需优化 github仓库:nnq NNQ框架搭建简单的DNN网络: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;time.h&gt;#include &lt;math.h&gt;#include &lt;queue&gt;#include &lt;math.h&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;#include &quot;NNQ/nnq.hpp&quot;using namespace nnq;nnl::Model m = &#123; Func::Linear(1,20,0.001), Func::Sigmoid(20), Func::Linear(20,20,0.001), Func::Sigmoid(20), Func::Linear(20,1,0.0001),&#125;;int main() &#123; qVec in(1); qVec out(1); qVec ideal(1); qVec loss(1); qVec grad(1); srand((unsigned)time(NULL)); mode = 1; for(int i = 0; i &lt; 20000; i++) &#123; for (int j = 0; j &lt; 100; j++) &#123; float a = sin(j / 10); in[0] = j/10; ideal[0] = a; out &lt;= m(in); Func::square_loss(loss,out, ideal, grad); m[grad]; &#125; qtype ls = loss[0]; cout &lt;&lt; ls &lt;&lt; endl; &#125; mode = 0; for (int j = 0; j &lt; 100; j++) &#123; int k = abs(rand()) % 100; float a = sin(k / 10); in[0] = k / 10; out &lt;= m(in); cout &lt;&lt; &quot;real:&quot; &lt;&lt; out[0] &lt;&lt; &quot; ideal:&quot; &lt;&lt; a &lt;&lt; endl; &#125;&#125;","categories":[{"name":"框架","slug":"框架","permalink":"https://tastynoob.github.io/categories/%E6%A1%86%E6%9E%B6/"},{"name":"人工智能","slug":"人工智能","permalink":"https://tastynoob.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"算法","slug":"算法","permalink":"https://tastynoob.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"神经网络","slug":"神经网络","permalink":"https://tastynoob.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"}]},{"title":"malloc实现","slug":"算法/malloc实现","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.171Z","comments":true,"path":"1970/01/01/算法/malloc实现/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/%E7%AE%97%E6%B3%95/malloc%E5%AE%9E%E7%8E%B0/","excerpt":"malloc实现","text":"malloc实现 下面主要介绍2种malloc实现 第一种是内存的块式管理，第二种是内存的链式管理 首先是贴代码 块式管理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;stdio.h&gt;typedef unsigned int u32;//块式管理，内存块的数量#define block_num 128typedef struct &#123; int mem[32];//一个块128字节&#125;block;#define block_size sizeof(block)typedef struct &#123; block blocks[block_num]; char table[block_num];&#125; alloc_mem;alloc_mem alloc_ptr;void myalloc_init() &#123; sizeof(alloc_mem); //初始化表项 for (int i = 0; i &lt; block_num ; i++) &#123; alloc_ptr.table[i] = 0; &#125;&#125;//分配内存空间void* myalloc(u32 size) &#123; //实际需要分配的连续内存块 int block_len = (size+8) / block_size + (((size+8) % block_size) ? 1 : 0); //从表单中搜索 for (int thp = 0; thp &lt; block_num - block_len + 1; thp++) &#123; int tep = thp + block_len; int bvld = 0;//内存块可用 for (int i = thp; i &lt; tep; i++) &#123; bvld |= alloc_ptr.table[i]; &#125; if (!bvld) &#123;//如果bvld==0，代表内存块可用 //设置占用 for (int i = thp; i &lt; tep; i++) &#123; alloc_ptr.table[i] = 1; &#125; //将内存块的前4个字节设置为块长度 *((int*)&amp;alloc_ptr.blocks[thp]) = block_len; *(((int*)&amp;alloc_ptr.blocks[thp]) + 1) = thp;//索引指针 return (void*)(((int*)&amp;alloc_ptr.blocks[thp])+2); &#125;//否则继续搜索 &#125; return NULL;//没有搜索到&#125;void myfree(void* ptr) &#123; int block_len = *((int*)ptr - 2); int thp = *((int*)ptr - 1); for (int i = thp; i &lt; thp + block_len; i++) &#123; alloc_ptr.table[i] = 0; &#125;&#125;int main() &#123; myalloc_init(); int* p = myalloc(10 * sizeof(int)); for (int i = 0; i &lt; 10; i++) &#123; p[i] = i + 1; &#125; for (int i = 0; i &lt; 10; i++) &#123; printf(&quot;%d\\n&quot;, p[i]); &#125;&#125; 链式管理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;typedef unsigned int u32;u32* buff;#define alloc_addr ((int)buff)#define alloc_size 1024*4typedef struct &#123; int size;//内存块大小 int avaliable;//是否激活 void* next;//下一个块&#125; mem_block;mem_block* alloc_head;void myalloc_init() &#123; buff = malloc(alloc_size); alloc_head = (mem_block*)buff; alloc_head-&gt;size = 0; alloc_head-&gt;avaliable = 0; alloc_head-&gt;next = 0;&#125;void* myalloc(u32 sizeofbyte) &#123; mem_block* temp = alloc_head;//指向当前块 if (sizeofbyte == 0) &#123; return NULL; &#125; //实际分配的大小 int real_size = 4 * (sizeofbyte / 4 + ((sizeofbyte % 4) ? 1 : 0)); while (1) &#123; if (temp-&gt;avaliable == 0) &#123; //当前块没有被使用 alloc_new: if (temp-&gt;next == 0) &#123; //假如下一个块为空，则分配当前块 //如果剩余空间不足以分配 if (((int)temp) + real_size &gt; alloc_addr + alloc_size) &#123; return NULL; &#125; temp-&gt;size = real_size; temp-&gt;avaliable = 1; temp-&gt;next = ((char*)temp + sizeof(mem_block)) + real_size; //没有超界 if ((temp-&gt;next &gt; buff) &amp;&amp; (((int)temp-&gt;next) + sizeof(mem_block) &lt; (alloc_addr + alloc_size))) &#123; ((mem_block*)temp-&gt;next)-&gt;size = 0; ((mem_block*)temp-&gt;next)-&gt;avaliable = 0; ((mem_block*)temp-&gt;next)-&gt;next = 0; &#125; break; &#125; else &#123; //下一个块不为空 if (temp-&gt;size &gt;= real_size) &#123; //如果当前块的大小满足要求 //如果当前块减去分配的内存，剩余的大小还能够再分配一个小块 if (temp-&gt;size - real_size &gt; sizeof(mem_block) + 4) &#123; //新块 mem_block* temp1 = (mem_block*)(((char*)(temp + 1)) + real_size); temp1-&gt;size = temp-&gt;size - real_size - sizeof(mem_block); temp1-&gt;avaliable = 0; temp1-&gt;next = temp-&gt;next; temp-&gt;next = temp1; temp-&gt;size = real_size; &#125; else&#123; real_size=temp-&gt;size; &#125; temp-&gt;avaliable = 1; break; &#125; else &#123; //不满足要求 (下一个块不为空并且当前块不满足要求) if (((mem_block*)temp-&gt;next)-&gt;avaliable == 0) &#123; // 如果下一个块没有激活，则可以分配到当前块 temp-&gt;size = temp-&gt;size + ((mem_block*)temp-&gt;next)-&gt;size + sizeof(mem_block);//重新分配当前块的大小 temp-&gt;next = ((mem_block*)temp-&gt;next)-&gt;next;//重新改变指向下一块的指针 goto alloc_new; //重新进行内存分配判断 &#125; else &#123;//下一个块已被激活，跳过 &#125; &#125; &#125; &#125; //如果指针指向正确 if ((temp-&gt;next &gt; buff) &amp;&amp; (temp-&gt;next &lt; (alloc_addr + alloc_size))) &#123; temp = temp-&gt;next; &#125; else &#123; return NULL; &#125; &#125; if (temp-&gt;size == real_size) &#123; return ((char*)temp + sizeof(mem_block)); &#125; return NULL;&#125;void myfree(void* ptr) &#123; if ((int)ptr &gt;= alloc_addr) &#123; mem_block* temp = ((mem_block*)ptr - 1); temp-&gt;avaliable = 0; &#125;&#125;int main() &#123; myalloc_init(); //[30,70] 00 000 00 int* p1 = myalloc(100); int* p2 = myalloc(200); int* p3 = myalloc(300); myfree(p1); p1 = myalloc(200); int* p4 = myalloc(30);&#125; 从代码可以看出，块式和链式最根本的区别就在去内存分块机制的不同 块式管理简单方便，但是内存利用率不高块式管理即简单的将内存分为固定的几块，然后建立一个查找表根据查找表分配内存 链式管理可以动态分配一定大小的内存块，内存利用率高，但是管理麻烦链式管理即使用链表动态分配内存和回收，每次分配内存需从头开始查找，如果有未利用内存还需重新分配较为复杂 以上代码仅供参考","categories":[{"name":"算法","slug":"算法","permalink":"https://tastynoob.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"系统","slug":"系统","permalink":"https://tastynoob.github.io/tags/%E7%B3%BB%E7%BB%9F/"}]},{"title":"PID算法","slug":"算法/pid算法","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.171Z","comments":true,"path":"1970/01/01/算法/pid算法/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/%E7%AE%97%E6%B3%95/pid%E7%AE%97%E6%B3%95/","excerpt":"PID算法","text":"PID算法 在系统控制领域，pid算法算是最常见的一种控制算法 由于PID算法比较简单 这里直接贴python代码 1234567891011121314151617181920212223#模拟pid控制器kp = 0.05ki = 0.01kd = 0.01#一次pid迭代last_error = 0integral = 0def pid_iteration(pv, set_point): global last_error global integral error = set_point - pv integral = integral + error derivative = error - last_error output = kp * error + ki * integral + kd * derivative last_error = error return outputstart = 0point = 100for i in range(0,100): start = start + pid_iteration(start, point) print(start)","categories":[{"name":"算法","slug":"算法","permalink":"https://tastynoob.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://tastynoob.github.io/tags/%E6%8A%80%E6%9C%AF/"},{"name":"信号处理","slug":"信号处理","permalink":"https://tastynoob.github.io/tags/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"}]},{"title":"pyaudio实现2点声源定位","slug":"算法/pyaudio实现2点声源定位","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.172Z","comments":true,"path":"1970/01/01/算法/pyaudio实现2点声源定位/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/%E7%AE%97%E6%B3%95/pyaudio%E5%AE%9E%E7%8E%B02%E7%82%B9%E5%A3%B0%E6%BA%90%E5%AE%9A%E4%BD%8D/","excerpt":"使用pyaudio和numpy设计的2点声源定位算法","text":"使用pyaudio和numpy设计的2点声源定位算法 不墨迹直接上代码代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import pyaudioimport numpy as npimport matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import Axes3D#2个麦克风nmicro=2#2个麦克风阵元的坐标,以麦克风a为原点,b为x轴负轴,单位:米#这里使用的是电脑麦克风,2个麦克风间距约为2分米pos = np.array([0,-0.2])print(pos)#PyAudio的信号采集参数CHUNK = 4800FORMAT = pyaudio.paInt16CHANNELS = 2RATE = 48000p = pyaudio.PyAudio()stream = p.open(format=FORMAT, channels=CHANNELS, rate=RATE, input=True, frames_per_buffer=CHUNK)#遍历的x，假设z为固定深度1mX_STEP=100x = np.linspace(-0.8, 0.8, X_STEP)A_STEP=100p = np.zeros(x.shape[0]) # 声强谱矩阵while True: data = stream.read(CHUNK,exception_on_overflow=False)#1600*2*2 data = np.frombuffer(data, dtype=np.short) data = data.reshape(CHUNK, 2)[:, :2].T#划分左右声道,shape:(2,1600) #傅里叶变换，在频域进行检测 data_n = np.fft.fft(data)/data.shape[1] # [2,1600] data_n = data_n[:, :data.shape[1]//2] #取前一半频率 data_n[:, 1:] *= 2 #将频率范围内的频率幅值翻倍 #宽带处理，对于50个不同的频率都进行计算 #r存储每个频率下对应信号的R矩阵 r = np.zeros((A_STEP, nmicro,nmicro), dtype=complex) for fi in range(1, A_STEP+1): #计算每个频率下的R矩阵 #自相关函数 rr = np.dot(data_n[:, fi*10-10:fi*10+10], data_n[:, fi*10-10:fi*10+10].T.conjugate())/nmicro r[fi-1, ...] = np.linalg.inv(rr) #MVDR搜索过程 for i in range(x.shape[0]): dm = np.sqrt(x[i]**2 + 1) delta_dn = pos*x[i]/dm #遍历角度 for fi in range(1, A_STEP+1): #计算导向向量 a = np.exp(-1j*2*np.pi*fi*100*delta_dn/340) p[i] = p[i] + 1 / np.abs(np.dot(np.dot(a.conjugate(), r[fi-1]), a))#计算每个频率下的声强谱 p /= np.max(p) #获取前5个最大值 p_max = np.argsort(p)[-5:] #输出声源所在的方向 print(np.average(p_max)) #以波形图显示声强谱 plt.clf() plt.plot(x, np.abs(p)) plt.xlabel(&#x27;x&#x27;) plt.ylabel(&#x27;p&#x27;) plt.pause(0.01) 有时间再仔细讲讲算法推导","categories":[{"name":"算法","slug":"算法","permalink":"https://tastynoob.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"信号处理","slug":"信号处理","permalink":"https://tastynoob.github.io/tags/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"},{"name":"声学","slug":"声学","permalink":"https://tastynoob.github.io/tags/%E5%A3%B0%E5%AD%A6/"}]},{"title":"一个简单的3d渲染器","slug":"算法/一个十分简单的3d渲染器","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.172Z","comments":true,"path":"1970/01/01/算法/一个十分简单的3d渲染器/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/%E7%AE%97%E6%B3%95/%E4%B8%80%E4%B8%AA%E5%8D%81%E5%88%86%E7%AE%80%E5%8D%95%E7%9A%843d%E6%B8%B2%E6%9F%93%E5%99%A8/","excerpt":"一个简单的3D渲染器仅支持三维物体的渲染不包括着色系统","text":"一个简单的3D渲染器仅支持三维物体的渲染不包括着色系统 闲来无事写的玩的项目 主要算法是利用矩阵乘法来实现对物体顶点的变换 再利用中心投影算法将物体投影到屏幕缓冲区上 实际上最主要的是如何投影,如何渲染 对于简单的3d渲染只需要使用很简单的算法即可实现 比如物体的旋转,平移,缩放均可使用初中知识 更进一步可以使用矩阵变换来实现更复杂的物体变换 这里使用矩阵变换进行操作 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//中心投影//认为摄像机位于(0,0,d)的位置Vec3 Project(Vec3&amp; a, qval d) &#123; Vec3 n; n[0] /= (1 - a[2] / d); n[1] /= (1 - a[2] / d); n[2] /= (1 - a[2] / d); return n;&#125;//矩阵乘法void Mat4Mul(TMat&amp; a, TMat&amp; b, TMat&amp; c) &#123; TMat temp; for (quint i = 0; i &lt; 4; i++) &#123; for (quint j = 0; j &lt; 4; j++) &#123; temp[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j] + a[i][2] * b[2][j] + a[i][3] * b[3][j]; &#125; &#125; c = temp;&#125;//绕x,y,z轴旋转void TMat::Rotate(qval x, qval y, qval z) &#123; //绕x轴旋转 float ax[4][4]&#123; &#123; 1, 0, 0, 0 &#125;, &#123; 0, cos(x), -sin(x), 0 &#125;, &#123; 0, sin(x), cos(x), 0 &#125;, &#123; 0, 0, 0, 1 &#125; &#125;; //绕y轴旋转 float ay[4][4]&#123; &#123; cos(y), 0, sin(y), 0 &#125;, &#123; 0, 1, 0, 0 &#125;, &#123; -sin(y), 0, cos(y), 0 &#125;, &#123; 0, 0, 0, 1 &#125; &#125;; //绕z轴旋转 float az[4][4]&#123; &#123; cos(z), -sin(z), 0, 0 &#125;, &#123; sin(z), cos(z), 0, 0 &#125;, &#123; 0, 0, 1, 0 &#125;, &#123; 0, 0, 0, 1 &#125; &#125;; TMat tempx(ax); TMat tempy(ay); TMat tempz(az); TMat temp; Mat4Mul(tempx, tempy, temp); Mat4Mul(temp, tempz, temp); Mat4Mul(temp, *this, *this);&#125;//平移void TMat::Translate(qval x, qval y, qval z) &#123; float a[4][4]&#123; &#123; 1, 0, 0, x &#125;, &#123; 0, 1, 0, y &#125;, &#123; 0, 0, 1, z &#125;, &#123; 0, 0, 0, 1 &#125; &#125;; TMat temp(a); Mat4Mul(temp, *this, *this);&#125;//缩放void TMat::Scale(qval x, qval y, qval z) &#123; float a[4][4]&#123; &#123; x, 0, 0, 0 &#125;, &#123; 0, y, 0, 0 &#125;, &#123; 0, 0, z, 0 &#125;, &#123; 0, 0, 0, 1 &#125; &#125;; TMat temp(a); Mat4Mul(temp, *this, *this);&#125;//中心投影//认为摄像机位于(0,0,d)的位置void TMat::Projection(qval d) &#123; float a[4][4]&#123; &#123; 1, 0, 0, 0 &#125;, &#123; 0, 1, 0, 0 &#125;, &#123; 0, 0, 1, 0 &#125;, &#123; 0, 0, -1/d, 1&#125; &#125;; TMat temp(a); Mat4Mul(temp, *this, *this);&#125;//对顶点应用变换矩阵void Vec3::Multiply(TMat&amp; tm) &#123; qval x = vec[0] * tm[0][0] + vec[1] * tm[0][1] + vec[2] * tm[0][2] + tm[0][3]; qval y = vec[0] * tm[1][0] + vec[1] * tm[1][1] + vec[2] * tm[1][2] + tm[1][3]; qval z = vec[0] * tm[2][0] + vec[1] * tm[2][1] + vec[2] * tm[2][2] + tm[2][3]; qval w = vec[0] * tm[3][0] + vec[1] * tm[3][1] + vec[2] * tm[3][2] + tm[3][3]; vec[0] = x / w; vec[1] = y / w; vec[2] = z / w;&#125; 对于物体渲染 最基本的是使用三角形进行物体渲染 将物体表面分割为三角形,并且把三角形渲染到屏幕上 然后要主要渲染的层次关系 比如一个三角形被另一个三角形遮挡,则需要把没有被遮挡的部分渲染出来 这里使用的是Z-buffer算法 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//利用叉乘判断点是否在三角形内部//vec3,vec3,vec3,vec2#define crossProduct(a, b, c, p) \\ Vec2 pa(a[0] - p[0], a[1] - p[1]);\\ Vec2 pb(b[0] - p[0], b[1] - p[1]);\\ Vec2 pc(c[0] - p[0], c[1] - p[1]);\\ bool k1 = (pa ^ pb) &gt;= 0;\\ bool k2 = (pb ^ pc) &gt;= 0;\\ bool k3 = (pc ^ pa) &gt;= 0;\\ avalid = (k1 &amp;&amp; k2 &amp;&amp; k3) || (!(k1||k2||k3));//在zbuff中绘制三角形//poscol:三个顶点的颜色(如果不使用颜色混合则使用第一个顶点的颜色)//use_colmix:是否使用颜色混合void DrawTriangle(Vec3 pos[3], qcol* poscol = nullptr , bool use_colmix = false) &#123; qval x1, y1, z1, x2, y2, z2, x3, y3, z3; x1 = pos[0][0] + screen_width / 2; y1 = screen_height / 2 - pos[0][1]; z1 = pos[0][2]; x2 = pos[1][0] + screen_width / 2; y2 = screen_height / 2 - pos[1][1]; z2 = pos[1][2]; x3 = pos[2][0] + screen_width / 2; y3 = screen_height / 2 - pos[2][1]; z3 = pos[2][2]; Vec3 npos[3]; npos[0][0] = x1; npos[0][1] = y1; npos[0][2] = z1; npos[1][0] = x2; npos[1][1] = y2; npos[1][2] = z2; npos[2][0] = x3; npos[2][1] = y3; npos[2][2] = z3; qval minX = min(x1, min(x2, x3)); minX = minX &lt; 0 ? 0 : minX; qval maxX = max(x1, max(x2, x3)); maxX = maxX &gt; screen_width ? screen_width : maxX; qval minY = min(y1, min(y2, y3)); minY = minY &lt; 0 ? 0 : minY; qval maxY = max(y1, max(y2, y3)); maxY = maxY &gt; screen_height ? screen_height : maxY; //求平面方程 qval ak, bk, ck, dk; // A = (y2 - y1)(z3 - z1) - (z2 - z1)(y3 - y1); ak = (npos[1][1] - npos[0][1]) * (npos[2][2] - npos[0][2]) - (npos[1][2] - npos[0][2]) * (npos[2][1] - npos[0][1]); // B = (x3 - x1)(z2 - z1) - (z3 - z1)(x2 - x1); bk = (npos[2][0] - npos[0][0]) * (npos[1][2] - npos[0][2]) - (npos[2][2] - npos[0][2]) * (npos[1][0] - npos[0][0]); // C = (x2 - x1)(y3 - y1) - (y2 - y1)(x3 - x1); ck = (npos[1][0] - npos[0][0]) * (npos[2][1] - npos[0][1]) - (npos[1][1] - npos[0][1]) * (npos[2][0] - npos[0][0]); // D = -(A * x1 + B * y1 + C * z1); dk = -(ak * npos[0][0] + bk * npos[0][1] + ck * npos[0][2]); for (quint px = minX;px &lt; maxX;px++) &#123; for (quint py = minY;py &lt; maxY;py++) &#123; Vec2 p_(px, py); //判断点是否在三角形内部 bool avalid; crossProduct(npos[0], npos[1], npos[2], p_); if (avalid) &#123; //计算p点的深度 qval pz = -(ak * px + bk * py + dk) / ck; //判断深度是否在摄像头视锥体内 if (pz &gt; Zbuf[py][px]) &#123; //计算深度 Zbuf[py][px] = pz; //计算颜色 Zcol[py][px] = poscol[0]; &#125; &#125; &#125; &#125;&#125; 这里仅展示部分代码,但也够用 对于简单的3d渲染也用不打破太复杂的技术 渲染效果如下","categories":[{"name":"算法","slug":"算法","permalink":"https://tastynoob.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"图形学","slug":"图形学","permalink":"https://tastynoob.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"前向求导算法","slug":"算法/前向求导算法","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.172Z","comments":true,"path":"1970/01/01/算法/前向求导算法/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/%E7%AE%97%E6%B3%95/%E5%89%8D%E5%90%91%E6%B1%82%E5%AF%BC%E7%AE%97%E6%B3%95/","excerpt":"前向求导算法","text":"前向求导算法 在神经网络当中需要利用反向传播算法对神经网络进行训练 又或者利用梯度下降法求局部最优解 但是我们又不想去手动求导 对于复杂的函数求导是件很痛苦的事 所以像是pytorch这类神经网络框架都提供了自动求导，或者自动微分机制 这里就来介绍下一种最简单的自动求导算法:前向求导 首先我们定义$\\epsilon$趋近于0，但是不等于0 因此$\\frac{f(x+\\epsilon)-f(x)}{\\epsilon}&#x3D;f^{‘}(x)$推导得$f(x+\\epsilon) &#x3D; f(x) + f^{‘}(x)\\epsilon$ 更一般的我们设二元数$a+b\\epsilon$,则有$f(a+b\\epsilon) &#x3D; f(a) + f^{‘}(a)b\\epsilon$ 至此我们就得到了一个求导的普遍公式即$f(a+b\\epsilon) &#x3D; f(a) + f^{‘}(a)b\\epsilon$其中$a\\in R,b\\in R,\\epsilon\\to0$ 为了方便计算，我们设二元数$a+b\\epsilon$其有如下特征$(a+b\\epsilon)+(c+d\\epsilon)&#x3D;(a+c)+(b+d)\\epsilon$由于$\\epsilon\\to0$,所以我们可以认为$\\epsilon^2&#x3D;0$类似于虚数单位$i^2&#x3D;-1$所以有乘法公式$(a+b\\epsilon)(c+d\\epsilon)&#x3D;ac+(ad+bc)\\epsilon$ 更进一步，根据$f(a+b\\epsilon) &#x3D; f(a) + f^{‘}(a)b\\epsilon$可以推导得$n^{(a+b\\epsilon)} &#x3D; n^a+(bn^a\\ln{n})\\epsilon,n\\in R$$(a+b\\epsilon)^n &#x3D; a^n + (nba^{n-1})\\epsilon,n\\in R$ 这就意味着二元数$a+b\\epsilon$满足所有的数学运算 只要我们已知函数$f(x)$我们通过代入二元数$f(a+\\epsilon)&#x3D;f(a)+f^{‘}(a)\\epsilon$就能求得该点的函数值和导数 这就是前向求导算法 具体代码可有python实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import numpy as npimport math#定义二元数,前向模式算法class Dual: a=0 e=0#无穷小量的系数 def __init__(self,a,e): self.a = a self.e = e def __add__(self,other): if type(other)!=Dual: return Dual(self.a+other,self.e) return Dual(self.a+other.a,self.e+other.e) def __radd__(self,other): return self.__add__(other) def __sub__(self,other): if type(other)!=Dual: return Dual(self.a-other,self.e) return Dual(self.a-other.a,self.e-other.e) def __rsub__(self,other): return self.__sub__(other) def __mul__(self,other): if type(other)!=Dual: return Dual(self.a*other,self.e*other) return Dual(self.a*other.a,self.a*other.e+self.e*other.a) def __rmul__(self,other): return self.__mul__(other) def __truediv__(self,other): if type(other)!=Dual: return Dual(self.a/other,self.e/other) return Dual(self.a/other.a,(self.e*other.a-self.a*other.e)/(other.a**2)) def __rtruediv__(self,other): return Dual(other/self.a, -other*self.e/self.a**2) #dual**x def __pow__(self,other): return Dual(self.a**other,other*self.a**(other-1)*self.e) #x**dual def __rpow__(self,other): return Dual(other**self.a,other**self.a*self.e*math.log(other)) #定义比较运算符 def __eq__(self,other): return self.a==other.a and self.e==other.e def __ne__(self,other): return not self.__eq__(other) def __gt__(self,other): return self.a&gt;other.a def __ge__(self,other): return self.a&gt;=other.a def __lt__(self,other): return self.a&lt;other.a def __le__(self,other): return self.a&lt;=other.a def __str__(self): return str(self.a) + (&#x27;+&#x27; if self.e &gt;= 0 else &#x27;&#x27;) +str(self.e)+&#x27;E&#x27; def __repr__(self): return str(self.a) + (&#x27;+&#x27; if self.e &gt;= 0 else &#x27;&#x27;) + str(self.e)+&#x27;E&#x27;def F(X): return 0.05*4*X**4 + 5.2*3*X**3 - 0.005*2*X**2 + 2.3*1*X + 12.3a = Dual(10,1)print(a)print(F(a))","categories":[{"name":"人工智能","slug":"人工智能","permalink":"https://tastynoob.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"算法","slug":"算法","permalink":"https://tastynoob.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"神经网络","slug":"神经网络","permalink":"https://tastynoob.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"}]},{"title":"反向求导算法","slug":"算法/反向求导算法","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.173Z","comments":true,"path":"1970/01/01/算法/反向求导算法/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/%E7%AE%97%E6%B3%95/%E5%8F%8D%E5%90%91%E6%B1%82%E5%AF%BC%E7%AE%97%E6%B3%95/","excerpt":"之前将了前向求导实现，现在就来讲一下反向求导实现","text":"之前将了前向求导实现，现在就来讲一下反向求导实现 反向求导的数学基础是链式法则 即求导的过程是从函数输出层开始，逐层向前求导，直到输入层，这样就可以求出每一层的梯度 对于标量求导，即可以自动求出所有变量的梯度 比如对于函数，利用链式法则求导 $Y&#x3D;F·G,F&#x3D;a+b,G&#x3D;b+1$$\\frac{\\partial Y}{\\partial a}$$&#x3D;\\frac{\\partial Y}{\\partial F}·\\frac{\\partial F}{\\partial a}+\\frac{\\partial Y}{\\partial G}·\\frac{\\partial G}{\\partial a}$$&#x3D;G + 0$$&#x3D;b + 1$ 其语法树如下：根据语法树求导,同路径下梯度相乘，不同路径梯度相加 $\\mathrm{d}a &#x3D; (b+1) \\times 1,\\mathrm{d}b&#x3D;(b+1) \\times 1 + (a+b) \\times 1$ 而不同的节点,比如加减乘除，其梯度的计算十分简单 通过把一个复杂的表达式转换为一颗只包含基本运算的语法二叉树 从上往下进行梯度迭代即可计算出每个变量的梯度 这与前向求导只能计算$\\mathrm{d}Y$不同,反向求导可以算出$\\frac{\\partial Y}{\\partial a},\\frac{\\partial Y}{\\partial a}$ 相加即可算出 $\\mathrm{d}Y$ 因此在工程应用时也是反向求导居多 以上就是反向求导的基本原理 现在我们来编写代码如何根据函数表达式构造语法二叉树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;typedef enum &#123; CONST, VAR, ADD, SUB, MUL, DIV, POW,&#125;Operator;class Qtype &#123;public: Operator oper=CONST; float val; float grad = 0; Qtype* left = nullptr; Qtype* right = nullptr; Qtype() &#123; oper = CONST; val = 0; &#125; Qtype(Operator oper) &#123; this-&gt;oper = oper; &#125; Qtype(float a) &#123; val = a; oper = CONST; &#125; Qtype(float a, Operator oper) &#123; val = a; this-&gt;oper = oper; &#125; Qtype(float a, float grad, Operator oper) &#123; val = a; this-&gt;grad = grad; this-&gt;oper = oper; &#125; Qtype&amp; operator+(Qtype&amp; other) &#123; Qtype* res = new Qtype(ADD); res-&gt;left = this; res-&gt;right = &amp;other; return *res; &#125; Qtype&amp; operator-(Qtype&amp; other) &#123; Qtype* res = new Qtype(SUB); res-&gt;left = this; res-&gt;right = &amp;other; return *res; &#125; Qtype&amp; operator*(Qtype&amp; other) &#123; Qtype* res = new Qtype(MUL); res-&gt;left = this; res-&gt;right = &amp;other; return *res; &#125; Qtype&amp; operator/(Qtype&amp; other) &#123; Qtype* res = new Qtype(DIV); res-&gt;left = this; res-&gt;right = &amp;other; return *res; &#125; Qtype&amp; operator=(Qtype&amp; other) &#123; val = other.val; grad = other.grad; oper = other.oper; left = other.left; right = other.right; return *this; &#125; Qtype&amp; operator^(Qtype&amp; other) &#123; Qtype* res = new Qtype(POW); res-&gt;left = this; res-&gt;right = &amp;other; return *res; &#125; Qtype&amp; operator+=(Qtype&amp; other) &#123; Qtype* copy = new Qtype(*this);//将自身拷贝一份 this-&gt;oper = ADD; this-&gt;left = copy; this-&gt;right = &amp;other; return *this; &#125; //反向求导 void Process(float grad) &#123; switch (oper) &#123; case CONST: grad = 0; break;//不做任何事情 case VAR: this-&gt;grad += grad;//梯度增加 break; case ADD: left-&gt;Process(grad); right-&gt;Process(grad); break; case SUB: left-&gt;Process(grad); right-&gt;Process(-grad); break; case MUL: left-&gt;Process(right-&gt;val * grad); right-&gt;Process(left-&gt;val * grad); break; case DIV: left-&gt;Process(1 / right-&gt;val * grad); right-&gt;Process(-left-&gt;val / (right-&gt;val * right-&gt;val) * grad); break; case POW: left-&gt;Process(right-&gt;val * pow(left-&gt;val, right-&gt;val - 1) * grad); right-&gt;Process(val * log(left-&gt;val) * grad); break; default: break; &#125; &#125; //前向传播 void Forward() &#123; switch (oper) &#123; case CONST: break; case VAR: grad = 0; break; case ADD: left-&gt;Forward(); right-&gt;Forward(); val = left-&gt;val + right-&gt;val; break; case SUB: left-&gt;Forward(); right-&gt;Forward(); val = left-&gt;val - right-&gt;val; break; case MUL: left-&gt;Forward(); right-&gt;Forward(); val = left-&gt;val * right-&gt;val; break; case DIV: left-&gt;Forward(); right-&gt;Forward(); val = left-&gt;val / right-&gt;val; break; case POW: left-&gt;Forward(); right-&gt;Forward(); val = pow(left-&gt;val, right-&gt;val); break; default: break; &#125; &#125; void Backward() &#123; Process(1); &#125; //打印语法树 void PrintTree() &#123; switch (oper) &#123; case CONST: cout &lt;&lt; val; break; case VAR: cout &lt;&lt; &quot;x&quot;; break; case ADD: cout &lt;&lt; &quot;(&quot;; left-&gt;PrintTree(); cout &lt;&lt; &quot;+&quot;; right-&gt;PrintTree(); cout &lt;&lt; &quot;)&quot;; break; case SUB: cout &lt;&lt; &quot;(&quot;; left-&gt;PrintTree(); cout &lt;&lt; &quot;-&quot;; right-&gt;PrintTree(); cout &lt;&lt; &quot;)&quot;; break; case MUL: cout &lt;&lt; &quot;(&quot;; left-&gt;PrintTree(); cout &lt;&lt; &quot;*&quot;; right-&gt;PrintTree(); cout &lt;&lt; &quot;)&quot;; break; case DIV: cout &lt;&lt; &quot;(&quot;; left-&gt;PrintTree(); cout &lt;&lt; &quot;/&quot;; right-&gt;PrintTree(); cout &lt;&lt; &quot;)&quot;; break; case POW: cout &lt;&lt; &quot;(&quot;; left-&gt;PrintTree(); cout &lt;&lt; &quot;^&quot;; right-&gt;PrintTree(); cout &lt;&lt; &quot;)&quot;; break; default: break; &#125; &#125;&#125;; 代码的复杂度与前向求导实际上差不多同样是通过重载运算符来实现自动构造语法二叉树 测试代码如下 12345678910int main() &#123; Qtype a(0, VAR), b(0, VAR),k(1); Qtype Y = (a + b) * (b + k); Y.Forward();//先前向传播一次计算各个节点的值，再反向传播计算梯度 Y.Backward(); Y.PrintTree();//打印语法树 cout &lt;&lt; endl; cout &lt;&lt; a.grad &lt;&lt; endl;//打印a的梯度 cout &lt;&lt; b.grad &lt;&lt; endl;//打印b的梯度&#125; 输出如下 123((x+x)*(x+1))11","categories":[{"name":"人工智能","slug":"人工智能","permalink":"https://tastynoob.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"算法","slug":"算法","permalink":"https://tastynoob.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"神经网络","slug":"神经网络","permalink":"https://tastynoob.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"}]},{"title":"卡尔曼滤波的公式详解","slug":"算法/卡尔曼滤波","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.173Z","comments":true,"path":"1970/01/01/算法/卡尔曼滤波/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/%E7%AE%97%E6%B3%95/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/","excerpt":"卡尔曼滤波的公式详解","text":"卡尔曼滤波的公式详解 对于初学者来说，卡尔曼滤波一堆的数理公式让人十分头大这里我们来对卡尔曼公式做出一个具体的解释 首先我们来看看基本卡尔曼的五个公式 $x_{t|t-1} &#x3D; Ax_{t-1|t-1} + B $$P_{t|t-1} &#x3D; AP_{t-1|t-1}A^T + Q_t $$K_t &#x3D; P_{t|t-1}H^T(HP_{t|t-1}H^T + R_t)^{-1} $$x_{t|t} &#x3D; K_tz_t + (E - K_tH)x_{t|t-1}$$P_{t|t} &#x3D; (E-K_tH)P_{t|t-1}$ 接下来我来仔细讲解各个公式的意义 卡尔曼滤波你可以理解为带有预测功能的平滑滤波器 在进行滤波时,考虑估计值与测量值得到计算值 我们要做的就是计算估计值与测量值之间的占比关系 首先是第一个公式 卡尔曼滤波要求 我们要根据某一规则得到当前时刻的预测值$\\hat{x}^-$ 根据普遍规律我们一般根据上一时刻的数据去预测当前时刻的数据$\\hat{x}^- &#x3D; x_{t|t-1}$ 则当前根据上一时刻的预测值我们可以描述为$x_{t|t-1} &#x3D; Ax_{t-1|t-1} + B$ 其中$x_{t-1|t-1}$表示上一时刻滤波得到的计算值$B$代表当前时刻的外加因素 比如某一汽车以加速度$a$做匀加速运动,$t-1$时刻汽车的速度为$v_{t-1}$ 则我们可以预测t时刻汽车的速度为$v_{t} &#x3D; v_{t-1} + a,A&#x3D;1,B&#x3D;a$ 对于有多个预测值，则是采用矩阵运算的方法，那么就可以得到卡尔曼滤波第一个公式$x_{t|t-1} &#x3D; Ax_{t-1|t-1} + B $其中$A$被称为状态转移矩阵，表示从$t-1$时刻的状态转到$t$时刻的状态$B$则称为控制矩阵，表示t时刻外界的控制量 第二个公式 我们知道，预测值不能表示真实值，因为真实过程当中总会有不同的干扰量 $t$时刻的真实值我们可以用下面的公式描述$x_t &#x3D; Ax_{t-1} + B + w_t$其中$x_t$表示t时刻的真实值,$w_t$表示外部噪声这里我们先假设噪声服从均值为0的正态分布$w_t \\sim N(0,\\sigma^2)$其协方差$cov(w_t)&#x3D;Q_t$ 则我们要描述理论估计值与真实值的误差有多少我们使用协方差矩阵$P_{t|t-1}$来表示$P_{t|t-1} &#x3D; cov(x_t-x_{t|t-1})$推导得$P_{t|t-1} &#x3D; cov(x_t-x_{t|t-1})$$&#x3D;cov(Ax_{t-1} + B + w_t - (Ax_{t-1|t-1}) + B )$$&#x3D;cov(A(x_{t-1}-x_{t-1|t-1})+w_t)$$&#x3D;Acov(x_{t-1}-x_{t-1|t-1})A^T + cov(w_t)$$&#x3D;AP_{t-1|t-1}A^T + Q_t$ 这样我们就得到了当前$t$时刻的理论估计值误差对于上面汽车的例子，假如汽车的速度误差服从$w_t \\sim N(0,0.05)$其中A&#x3D;1则汽车速度的估计误差可以表示为$P_{t|t-1}&#x3D;1 \\times P_{t-1|t-1} \\times 1 + 0.05$ 对于多个估计误差则是卡尔曼第二个公式的矩阵形式 第三个公式 既然我们得到了预测值与预测误差 那我们就要根据预测值与传感器的测量值综合评价，得到滤波后的计算值 首先传感器的测量值肯定不是直接可以利用的数据 比如汽车的速度，传感器可能通过加速度的积分来间接得到速度 因此测量值可以描述为 $z_t &#x3D; Hx_t + v_t$ 其中$H$为变换矩阵,用于将真实值映射到测量值对应的空间来比如$x_t$为真实速度,$z_t$为测量的加速度,则需要将速度映射到加速度对应的空间来$v_t$用来表示测量误差，假设$v_t$服从均值为0的正态分布$v_t\\sim N(0,\\sigma^2)$其协方差为$cov(v_t) &#x3D; R_t$ 假如$z_t$测量值近似等于真实值，则$H$可以设为1(矩阵形式则为E) 现在我们知道了测量值与真实值的关系 那么和第二个公式一样，我们也需要知道测量值与与估计值之间的误差我们使用协方差矩阵$S_t$来表示，则$S_t &#x3D; cov(z_t - Hx_{t|t-1})$ 推导得$S_t &#x3D; cov(z_t - Hx_{t|t-1})$$&#x3D; cov(Hx_t + v_t - Hx_{t|t-1})$$&#x3D; cov(H(x_t-x_{t|t-1}H^T)) + cov(v_t)$$&#x3D;HP_{t|t-1}H^T + R_t$ 有了估计值的估计误差$P_{t|t-1}$与测量值的测量误差$S_t$对于上面汽车的例子，假如测量误差$v_t \\sim N(0,0.05)$,则$R_t&#x3D;0.05$ 我们就可以描述估计值与测量值之间的关系，接下来我们就要对估计值与测量值进行融合 我们肯定是希望误差越小的一边占比越大，误差越大的一边占比越小 那么我们可以定义$K_t &#x3D; P_{t|t-1}H^TS^{-1}_t$ 来描述估计值与测量值之间的占比关系，这里$K_t$被称为卡尔曼增益化简得$K_t &#x3D; P_{t|t-1}H^T(HP_{t|t-1}H^T + R_t)^{-1}$ 即卡尔曼第三个公式 第四个公式 我们现在知道了估计值与测量值之间的占比关系 那么我们就能根据这个关系进行融合得到滤波后的计算值,则 $x_{t|t} &#x3D; K_tz_t + (E-K_tH)x_{t|t-1}$其中$E$是单位矩阵，当估计值与测量值只有一个时，用1表示$K_t$即表示测量值的占比，相对的$1-K_tH$表示估计值的占比 即卡尔曼第四个公式 第五个公式 得到滤波后的计算值后，我们还要继续更新估计值的误差我们知道估计值占比$1-K_tH$那么新的估计值误差也应更新，即 $P_{t|t} &#x3D; (1-K_TH)P_{t|t-1}$ 这样我们就完成了一次卡尔曼滤波循环 对于单传感器滤波，上式可转换为代数式 python测试代码如下 1234567891011121314151617181920212223242526272829import mathimport numpy as npimport matplotlib.pyplot as plt#卡尔曼滤波#假设某一温度传感器的波形服从对数分布X= np.linspace(0,100,100)wave_orig = np.log(X+1)wave = wave_orig + np.random.normal(0,0.05,100)#添加噪点#滤波后的波形wave_filtered = np.zeros(100)wave_filtered[0] = wave[0]P_11 = 0.5#初始预测误差for i in range(1,100): #理论预测 x_21 = wave_filtered[i-1] + math.log(i+1) - math.log(i) #理论估计误差 P_21 = P_11 + 0.05 #实际测量值 z_2 = wave[i] #理论估计值与测量值的误差 S_2 = P_21 + 0.05 #计算卡尔曼增益 K_2 = P_21 / S_2 wave_filtered[i] = K_2 * z_2 + (1-K_2) * x_21 P_11 = (1-K_2) * P_21","categories":[{"name":"算法","slug":"算法","permalink":"https://tastynoob.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://tastynoob.github.io/tags/%E6%8A%80%E6%9C%AF/"},{"name":"信号处理","slug":"信号处理","permalink":"https://tastynoob.github.io/tags/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"}]},{"title":"快速傅里叶变换","slug":"算法/快速傅里叶变换","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.173Z","comments":true,"path":"1970/01/01/算法/快速傅里叶变换/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/","excerpt":"快速傅里叶变换及逆变换","text":"快速傅里叶变换及逆变换 快速傅里叶变换是在离散傅里叶的基础上的优化型 本质是一样的 首先我们来看看离散傅里叶变换的公式：$D(k) &#x3D; \\sum_{n&#x3D;0}^{N-1}E(n)(\\cos\\frac{2\\pi kn}{N} - j\\sin\\frac{2\\pi kn}{N})$ 方便期间我们设$W^{n}_{N} &#x3D; \\cos\\frac{2\\pi n}{N} + j\\sin\\frac{2\\pi n}{N}&#x3D;e^{j\\frac{2\\pi n}{N}}$即欧拉公式的变体 $W^{n}{N}$有如下特性$W^{a}{N} * W^{b}{N} &#x3D; W^{a+b}{N}$$W^{a + \\frac{N}{2}}{N} &#x3D; \\cos{(\\frac{2\\pi n}{N} + \\pi)} + j\\sin{(\\frac{2\\pi n}{N} + \\pi)} &#x3D; -W^{a}{N}$$W^{a + N}{N} &#x3D; \\cos{(\\frac{2\\pi n}{N} + 2\\pi)} + j\\sin{(\\frac{2\\pi n}{N} + 2\\pi)} &#x3D; W^{a}{N}$该特性也是快速傅里叶的关键 则$D(k) &#x3D; \\sum_{n&#x3D;0}^{N-1}E(n)W^{-kn}{N}$$D(k) &#x3D; E(0)W^{0}{N} + E(1)W^{-k}{N} + E(2)W^{-2k}{N} + E(3)W^{-3k}{N} + … + E(N-1)W^{-(N-1)k}{N}$ 可以得到：(N必须为2的次方,则n最大为N-1)$D(k) &#x3D; (E(0) + E(2)W^{-2k}{N} + … + E(N-2)W^{-(N-2)k}{N}) + (E(1)W^{-1k}{N} + E(3)W^{-3k}{N} + … + E(N-1)W^{-(N-1)k}{N})$$D(k) &#x3D; (E(0) + E(2)W^{-2k}{N} + … + E(N-2)W^{-(N-2)k}{N}) + W^{-1k}{N}(E(1) + E(3)W^{-2k}{N} + … + E(N-1)W^{-(N-2)k}{N})$ 设$D1(k) &#x3D; E(0) + E(2)W^{-2k}{N} + … + E(N-2)W^{-(N-2)k}{N}$$D2(k) &#x3D; E(1) + E(3)W^{-2k}{N} + … + E(N-1)W^{-(N-2)k}{N}$ 则我们可以得到D(k)的递推式$D(k) &#x3D; D1(k) + W^{-1k}{N}D2(k)$$D(k+\\frac{N}{2}) &#x3D; D1(k) - W^{-1k}{N}D2(k)$$0&lt;&#x3D;k&lt;&#x3D;\\frac{N}{2}-1$ 当N&#x3D;1时$D(k) &#x3D; E(0)$ 由其递归式我们就可以写出快速傅里叶递归代码 12345678910def FFT(x): N = len(x) if N &lt;= 1: return x even = FFT(x[0::2])#取出偶数项 odd = FFT(x[1::2])#取出奇数项 #计算W*D2 T = [np.exp(-2j * math.pi * k / N) * odd[k] for k in range(N//2)] #合并前面一半和后面一半 return [even[k] + T[k] for k in range(N//2)] + [even[k] - T[k] for k in range(N//2)] 由离散傅里叶逆变换公式$ID(k) &#x3D; \\frac{1}{N}\\sum_{n&#x3D;0}^{N-1}D(n)(cos\\frac{2\\pi kn}{N} + jsin\\frac{2\\pi kn}{N})$ 同理可得快速傅里叶的逆变换推导过程与上面相似与正变换的唯一区别在于$W^{-nk}_{N}$中负号去掉了 123456789101112def IFFT(x, n=0): N = len(x) if N &lt;= 1: return x even = IFFT(x[0::2], n+1) odd = IFFT(x[1::2], n+1) #这里与傅里叶变换的唯一区别就在于符号变了 T = [np.exp(2j * math.pi * k / N) * odd[k] for k in range(N//2)] if n == 0: return [(even[k] + T[k])/N for k in range(N//2)] + [(even[k] - T[k])/N for k in range(N//2)] return [(even[k] + T[k]) for k in range(N//2)] + [even[k] - T[k] for k in range(N//2)]","categories":[{"name":"算法","slug":"算法","permalink":"https://tastynoob.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://tastynoob.github.io/tags/%E6%8A%80%E6%9C%AF/"},{"name":"信号处理","slug":"信号处理","permalink":"https://tastynoob.github.io/tags/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"}]},{"title":"简单的滤波算法","slug":"算法/滤波","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.174Z","comments":true,"path":"1970/01/01/算法/滤波/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/%E7%AE%97%E6%B3%95/%E6%BB%A4%E6%B3%A2/","excerpt":"简单的滤波算法","text":"简单的滤波算法 卷积一维滤波 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import numpy as npimport mathimport matplotlib.pyplot as plt################################一维滤波###############################start_X = -np.piend_x = np.pislice_num = 200 #切分X = np.linspace(start_X,end_x,slice_num,endpoint=True) #X轴向wave1 = 10*np.sin(X) + 5*np.append(np.random.rand(len(X)-100),np.zeros(100))#使用复数代表波形，实部代表时间轴，虚部代表幅度wave1 = X + wave1 * 1jwave1_real=np.real(wave1)wave1_imag=np.imag(wave1)#将波形旋转90度#wave1 = wave1 * 1jplt.title(&#x27;original data&#x27;)plt.plot(np.real(wave1), np.imag(wave1))plt.show()# 卷积滤波 使用复数wave2 = []filter1 = [0.2,0.3,0.5]for i in range(len(wave1) - len(filter1) + 1): point = 0 for j in range(len(filter1)): point += wave1[i+j] * filter1[j] wave2.append(point)wave2 = np.array(wave2)fig=plt.figure()plt.title(&#x27;Convolution filtering consider the time axis&#x27;)plt.plot(np.real(wave2), np.imag(wave2))plt.show()# 卷积滤波 不使用复数wave2 = []for i in range(len(wave1_imag) - len(filter1) + 1): point = 0 for j in range(len(filter1)): point += wave1_imag[i+j] * filter1[j] wave2.append(point)for j in range(len(filter1) - 1): wave2.append(0)wave2 = np.array(wave2)fig=plt.figure()plt.title(&#x27;Convolution filtering does not consider the time axis&#x27;)plt.plot(np.real(wave1),wave2)plt.show()# 普通平滑滤波 #老数据加权和wave2 = []#注意此处的滤波器是老数据的各个加权和filter2 = [0.4,0.4,0.5]last = [0,0]#保存老数据for i in range(len(wave1_imag)): k=0 for j in range(len(filter2)-1):#先加权老数据 k += last[j] * filter2[j] #再加权新数据 k += wave1_imag[i] * filter2[-1] #删除最老的一个数据 del last[0] #添加新数据 last.append(k) wave2.append(last[-1])wave2 = np.array(wave2)fig=plt.figure()plt.title(&#x27;Ordinary smoothing filter&#x27;)plt.plot(X,wave2)plt.show() 滤波效果: 多维滤波 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import numpy as npimport mathimport matplotlib.pyplot as pltimport cv2################################ 二维滤波###############################start_X = -np.piend_x = np.pislice_num = 200 # 切分X = np.linspace(start_X, end_x, slice_num, endpoint=True) # X轴向wave1 = 10*np.sin(X) + np.append(np.random.rand(len(X)-100), np.zeros(100))wave1 = X + wave1 * 1jwave1_real = np.real(wave1)wave1_imag = np.imag(wave1)wave2 = 10*np.sin(X) + np.append(np.random.rand(len(X)-100), np.zeros(100))wave2 = X + wave2 * 1jwave2_real = np.real(wave1)wave2_imag = np.imag(wave1)plt.title(&#x27;original data1&#x27;)plt.plot(np.real(wave1), np.imag(wave1))fig = plt.figure()plt.title(&#x27;original data2&#x27;)plt.plot(np.real(wave2), np.imag(wave2))plt.show()# 二维卷积滤波,常用于2个或多个传感器滤波减少误差wave = [wave1, wave2]wave3 = []filter1 = [[0.5,0.5], [0.5,0.5]]for i in range(len(wave1) - len(filter1) + 1): point = 0 for j in range(len(filter1)): # 2行 for k in range(len(filter1[0])): # 2列 point += filter1[j][k] * wave[j][i+k] wave3.append(point)wave3 = np.array(wave3)fig = plt.figure()plt.title(&#x27;filter data&#x27;)plt.plot(np.real(wave3), np.imag(wave3))plt.show()# 二维图像滤波，这里是直接调opencv库fig = plt.figure()plt.title(&#x27;original image&#x27;)img = plt.imread(&quot;0.jpg&quot;)plt.imshow(img)# 卷积核kernel = np.array([ [1, -2, 1], [1, -2, 1], [1, -2, 1]])res = cv2.filter2D(img, -1, kernel)fig = plt.figure()plt.title(&#x27;filter image&#x27;)plt.imshow(res) 滤波效果: 傅里叶滤波 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import numpy as npimport mathimport matplotlib.pyplot as plt################################离散傅里叶变换 时域转频域###############################start_X = -2*np.piend_x = 2*np.pislice_num = 200 #切分X = np.linspace(start_X,end_x,slice_num,endpoint=True) #X轴向#在原始波形的基础上添加噪点wave1 = 10*np.sin(X) + 5*np.append(np.random.rand(len(X)-100),np.zeros(100))wave1 = X + wave1 * 1jwave1_real=np.real(wave1)wave1_imag=np.imag(wave1)# wave1 = wave1plt.title(&#x27;original data&#x27;)plt.plot(np.real(wave1), np.imag(wave1))plt.show()pi = 3.1415926def DFT(origin): # 计算给定序列的离散傅里叶变换结果 N= len(origin) output = [] for i in range(N): temp = 0 for j in range(N): temp += origin[j] * ( (math.cos(2 * math.pi * i * j / N) - math.sin(2 * math.pi * i * j / N) * 1j) ) output.append(temp) return outputdef IDFT(origin): #逆变换 N= len(origin) output = [] for i in range(N): temp = 0 for j in range(N): temp += origin[j] * ( (math.cos(2 * math.pi * i * j / N) + math.sin(2 * math.pi * i * j / N) * 1j) ) output.append(temp / N) return output#dft输出 , 对波形1做傅里叶变换dft_wave = DFT(wave1_imag)#idft输出 逆变换idft_wave = IDFT(dft_wave)fig = plt.figure()plt.title(&#x27;DFT abs data&#x27;)plt.plot(np.real(wave1), np.abs(dft_wave))plt.show()fig = plt.figure()plt.title(&#x27;IDFT data&#x27;)plt.plot(np.real(wave1), np.real(idft_wave))plt.show()#傅里叶滤波dft_new_wave = dft_wave.copy()#过滤杂波，将频谱图上的杂波过滤for i in range(len(dft_new_wave)): if(dft_new_wave[i].__abs__() &lt;= 200): dft_new_wave[i]=0#逆变换得到无杂波的波形idft_wave = IDFT(dft_new_wave)fig = plt.figure()plt.title(&#x27;DFT filter data&#x27;)plt.plot(np.real(wave1), np.real(idft_wave))plt.show() 傅里叶滤波效果:","categories":[{"name":"算法","slug":"算法","permalink":"https://tastynoob.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://tastynoob.github.io/tags/%E6%8A%80%E6%9C%AF/"},{"name":"信号处理","slug":"信号处理","permalink":"https://tastynoob.github.io/tags/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"}]},{"title":"离散傅里叶变换","slug":"算法/离散傅里叶变换","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.174Z","comments":true,"path":"1970/01/01/算法/离散傅里叶变换/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/%E7%AE%97%E6%B3%95/%E7%A6%BB%E6%95%A3%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/","excerpt":"离散傅里叶变换及逆变换","text":"离散傅里叶变换及逆变换 这里直接上离散傅里叶变换的数学公式: 用D(x)代表傅里叶变换输出，E(x)代表原始波形数据用ID(x)代表傅里叶逆变换输出(x&#x3D;0,1,2,3…)用N代表数据量，也就是采样点数量 $D(k) &#x3D; \\sum_{n&#x3D;0}^{N-1}E(n)(cos\\frac{2\\pi kn}{N} - jsin\\frac{2\\pi kn}{N})$$ID(k) &#x3D; \\frac{1}{N}\\sum_{n&#x3D;0}^{N-1}D(n)(cos\\frac{2\\pi kn}{N} + jsin\\frac{2\\pi kn}{N})$ 其中的”j”代表虚数单位 python代码如下 12345678910111213141516171819202122232425262728import mathpi = 3.1415926def DFT(origin): # 计算给定序列的离散傅里叶变换结果 N= len(origin) output = [] for i in range(N): temp = 0 for j in range(N): temp += origin[j] * ( (math.cos(2 * math.pi * i * j / N) - math.sin(2 * math.pi * i * j / N) * 1j) ) output.append(temp) return outputdef IDFT(origin): N= len(origin) output = [] for i in range(N): temp = 0 for j in range(N): temp += origin[j] * ( (math.cos(2 * math.pi * i * j / N) + math.sin(2 * math.pi * i * j / N) * 1j) ) output.append(temp / N) return output 样例：滤波 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import numpy as npimport mathimport matplotlib.pyplot as pltstart_X = -2*np.piend_x = 2*np.pislice_num = 200 #切分X = np.linspace(start_X,end_x,slice_num,endpoint=True) #X轴向wave1 = 10*np.sin(X) + 5*np.append(np.random.rand(len(X)-100),np.zeros(100))wave1 = X + wave1 * 1jwave1_real=np.real(wave1)wave1_imag=np.imag(wave1)plt.title(&#x27;original data&#x27;)plt.plot(np.real(wave1), np.imag(wave1))plt.show()pi = 3.1415926def DFT(origin): # 计算给定序列的离散傅里叶变换结果 N= len(origin) output = [] for i in range(N): temp = 0 for j in range(N): temp += origin[j] * ( (math.cos(2 * math.pi * i * j / N) - math.sin(2 * math.pi * i * j / N) * 1j) ) output.append(temp) return outputdef IDFT(origin): N= len(origin) output = [] for i in range(N): temp = 0 for j in range(N): temp += origin[j] * ( (math.cos(2 * math.pi * i * j / N) + math.sin(2 * math.pi * i * j / N) * 1j) ) output.append(temp / N) return output#dft输出 , 对波形1做傅里叶变换dft_wave = DFT(wave1_imag)#idft输出 逆变换idft_wave = IDFT(dft_wave)#傅里叶滤波dft_new_wave = dft_wave.copy()#过滤杂波for i in range(len(dft_new_wave)): if(dft_new_wave[i].__abs__() &lt;= 200): dft_new_wave[i]=0idft_wave = IDFT(dft_new_wave)fig = plt.figure()plt.title(&#x27;DFT filter data&#x27;)plt.plot(np.real(wave1), np.real(idft_wave))plt.show() 结果:","categories":[{"name":"算法","slug":"算法","permalink":"https://tastynoob.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://tastynoob.github.io/tags/%E6%8A%80%E6%9C%AF/"},{"name":"信号处理","slug":"信号处理","permalink":"https://tastynoob.github.io/tags/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"}]},{"title":"一个计算器的语法分析器","slug":"算法/计算器语法分析","date":"1970-01-01T00:00:00.000Z","updated":"2023-04-28T16:56:51.175Z","comments":true,"path":"1970/01/01/算法/计算器语法分析/","link":"","permalink":"https://tastynoob.github.io/1970/01/01/%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%97%E5%99%A8%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/","excerpt":"之前做了个计算器项目，用到了语法分析，我也是对语法分析方面很感兴趣，就来写一篇博客","text":"之前做了个计算器项目，用到了语法分析，我也是对语法分析方面很感兴趣，就来写一篇博客 先把所有代码粘贴上这个计算器的语法分析采用抽象语法分析，其语法表达式为: 12345678expr : term + term | term - term | termterm : pri * pri | pri / pri | pripri : num | &#x27;(&#x27; expr &#x27;)&#x27; 代码挺简单的，拓展性也挺强,可直接复制粘贴 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include &lt;math.h&gt;#include &lt;string.h&gt;typedef struct &#123; char tag; float val;&#125; Token;typedef struct &#123; char* str; int p; Token buffer; char null;&#125; Parser;//用来缓存数据 //创建一个tokenToken CreateToken(char ch);Token CreateToken_(char ch,float v);Parser parser = &#123; 0,0,&#123;0&#125;,1 &#125;;int error_flag =0;float Term();Token Get();float Expression();float Primary();void Error()&#123;//错误处理函数，这里可以随便改 error_flag = 1;&#125;//创建一个tokenToken CreateToken(char ch)&#123; Token t = &#123;ch,0&#125;; return t;&#125;Token CreateToken_(char ch,float v)&#123; Token t = &#123;ch,v&#125;; return t;&#125;void Push(Token* t)&#123; if(!parser.null)&#123; Error(); &#125; parser.buffer = *t; parser.null=0;&#125;Token Get()&#123; if(!parser.null)&#123; parser.null=1; return parser.buffer; &#125; char ch = parser.str[parser.p++]; float val; switch (ch) &#123; case &#x27;=&#x27;: return CreateToken(ch); case &#x27;+&#x27;:case &#x27;-&#x27;:case &#x27;*&#x27;:case &#x27;/&#x27;:case &#x27;(&#x27;:case &#x27;)&#x27;: return CreateToken(ch); case &#x27;0&#x27;:case &#x27;1&#x27;:case &#x27;2&#x27;:case &#x27;3&#x27;:case &#x27;4&#x27;: case &#x27;5&#x27;:case &#x27;6&#x27;:case &#x27;7&#x27;:case &#x27;8&#x27;:case &#x27;9&#x27;: parser.p--; sscanf(&amp;parser.str[parser.p],&quot;%f&quot;,&amp;val); while((parser.str[parser.p]&lt;=&#x27;9&#x27; &amp;&amp; parser.str[parser.p]&gt;=&#x27;0&#x27;) || parser.str[parser.p]==&#x27;.&#x27;)parser.p++; return CreateToken_(&#x27;0&#x27;,val); case &#x27;s&#x27;:case &#x27;c&#x27;:case &#x27;t&#x27;: return CreateToken(ch); default: return CreateToken(ch); &#125;&#125;float Expression()&#123;//expr表达式 float val = Term(); Token t = Get(); while (t.tag == &#x27;+&#x27; || t.tag == &#x27;-&#x27;) &#123; if (t.tag == &#x27;+&#x27;) &#123; val += Term(); t = Get(); &#125; if (t.tag == &#x27;-&#x27;) &#123; val -= Term(); t = Get(); &#125; &#125; Push(&amp;t); return val;&#125;float Term()&#123;//term表达式 float val = Primary(); while (1) &#123; Token token = Get(); switch (token.tag) &#123; case &#x27;*&#x27;: val *= Primary(); break; case &#x27;/&#x27;: val /= Primary(); break; default: Push(&amp;token); return val; &#125; &#125;&#125;float Primary() &#123;//pri表达式 float val=0; Token token = Get(); switch (token.tag) &#123; case &#x27;0&#x27;: val = token.val; break; case &#x27;(&#x27;: val = Expression(); token = Get(); if (token.tag != &#x27;)&#x27;) &#123; Error(); &#125; break; default: Error(); &#125; return val;&#125;float ParseGet(char* str)&#123; parser.str = str; float val=0; while (1) &#123; Token token = Get(); if (token.tag == &#x27;=&#x27;) &#123; parser.null=1; parser.p=0; parser.str=0; return val; &#125; else &#123; Push(&amp;token); val = Expression(); &#125; if (error_flag)&#123; error_flag = 0; parser.null=1; parser.p=0; parser.str=0; return FLT_MAX; &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://tastynoob.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"语法分析","slug":"语法分析","permalink":"https://tastynoob.github.io/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"},{"name":"lex&yacc","slug":"lex-yacc","permalink":"https://tastynoob.github.io/tags/lex-yacc/"}]}],"categories":[{"name":"处理器设计","slug":"处理器设计","permalink":"https://tastynoob.github.io/categories/%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/"},{"name":"人工智能","slug":"人工智能","permalink":"https://tastynoob.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"算法","slug":"算法","permalink":"https://tastynoob.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"其它","slug":"其它","permalink":"https://tastynoob.github.io/categories/%E5%85%B6%E5%AE%83/"},{"name":"linux","slug":"linux","permalink":"https://tastynoob.github.io/categories/linux/"},{"name":"框架","slug":"框架","permalink":"https://tastynoob.github.io/categories/%E6%A1%86%E6%9E%B6/"},{"name":"fpga","slug":"fpga","permalink":"https://tastynoob.github.io/categories/fpga/"}],"tags":[{"name":"riscv","slug":"riscv","permalink":"https://tastynoob.github.io/tags/riscv/"},{"name":"神经网络","slug":"神经网络","permalink":"https://tastynoob.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"name":"arm","slug":"arm","permalink":"https://tastynoob.github.io/tags/arm/"},{"name":"k210","slug":"k210","permalink":"https://tastynoob.github.io/tags/k210/"},{"name":"linux","slug":"linux","permalink":"https://tastynoob.github.io/tags/linux/"},{"name":"系统","slug":"系统","permalink":"https://tastynoob.github.io/tags/%E7%B3%BB%E7%BB%9F/"},{"name":"vscode","slug":"vscode","permalink":"https://tastynoob.github.io/tags/vscode/"},{"name":"test","slug":"test","permalink":"https://tastynoob.github.io/tags/test/"},{"name":"技术","slug":"技术","permalink":"https://tastynoob.github.io/tags/%E6%8A%80%E6%9C%AF/"},{"name":"nodejs","slug":"nodejs","permalink":"https://tastynoob.github.io/tags/nodejs/"},{"name":"LVGL","slug":"LVGL","permalink":"https://tastynoob.github.io/tags/LVGL/"},{"name":"verilog","slug":"verilog","permalink":"https://tastynoob.github.io/tags/verilog/"},{"name":"chisel","slug":"chisel","permalink":"https://tastynoob.github.io/tags/chisel/"},{"name":"信号处理","slug":"信号处理","permalink":"https://tastynoob.github.io/tags/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"},{"name":"声学","slug":"声学","permalink":"https://tastynoob.github.io/tags/%E5%A3%B0%E5%AD%A6/"},{"name":"图形学","slug":"图形学","permalink":"https://tastynoob.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"语法分析","slug":"语法分析","permalink":"https://tastynoob.github.io/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"},{"name":"lex&yacc","slug":"lex-yacc","permalink":"https://tastynoob.github.io/tags/lex-yacc/"}]}